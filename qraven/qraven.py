# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QRaven

 A QGIS plugin to help generate input files for Raven
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-03-22
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Francis Lapointe
        email                : francis.lapointe5@usherbrooke.ca
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from pathlib import Path
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import *
from PyQt5.QtWebKitWidgets import *
from PyQt5.QtWebKit import QWebSettings
#from PyQt5 import QFileDialog
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .qraven_dialog import QRavenDialog
from qgis.core import Qgis, QgsVectorLayer, QgsRasterLayer, QgsProject, QgsSettings,QgsFeature,QgsGeometry,QgsField
from sys import platform
import matplotlib.pyplot as plt
import csv, datetime, webbrowser, ntpath, os.path, requests,re
from .modules.docker.dockercmd import Docker
from .modules.calibration.ostrich import  Ostrich
from .modules.resetgui import *
from .modules.templates.hmets import loadHmets 
from .modules.templates.hbvec import loadHbvec
from .modules.templates.hbvlight import loadHbvlight
from .modules.templates.ubcwm import loadUbcwm
from .modules.templates.gr4j import loadGr4j
from .modules.templates.canshield import loadCanshield
from .modules.templates.mohyse import loadMohyse
from .modules.templates.hypr import loadHypr
from .modules.templates.hymod import loadHymod
from .modules.templates.awbm import loadAwbm
from .modules.PyRavenR import *
from .modules import customoutputs, hydrologicproc
from .modules.datascrapers import streamflow
from .modules.datascrapers.gisdata import gisScraper


class QRaven:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'QRaven_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&QRaven')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('QRaven', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/qraven/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Generate Raven input files'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&QRaven'),
                action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = QRavenDialog()
        
            self.loadsettings()
            self.setupMenubar()
            self.checkUpdate()
            self.setStreamflowComboboxes()
            self.setOstrichComboboxes()

            #Initialize the Docker commands
            self.docker = Docker(computerOS, separator, self.containerization, self.registry, self.containerimage)

            #Initialize the OSTRICH module
            self.ostrich = Ostrich()
            
            self.dlg.list_evalmetrics.sortItems()
            self.stations = []
            self.waterofficestations = []

            self.dlg.sidemenu.currentRowChanged.connect(self.display)
            self.dlg.combo_menubar.currentTextChanged.connect(self.setMenuStyle)
            #-------------Raven RVI-------------#
            self.dlg.btn_load_hmets.clicked.connect(self.loadModels)
            self.dlg.btn_load_hbvec.clicked.connect(self.loadModels)
            self.dlg.btn_load_hbvlight.clicked.connect(self.loadModels)
            self.dlg.btn_load_ubcwm.clicked.connect(self.loadModels)
            self.dlg.btn_load_gr4j.clicked.connect(self.loadModels)
            self.dlg.btn_load_canadianshield.clicked.connect(self.loadModels)
            self.dlg.btn_load_mohyse.clicked.connect(self.loadModels)
            self.dlg.btn_load_hypr.clicked.connect(self.loadModels)
            self.dlg.btn_load_hymod.clicked.connect(self.loadModels)
            self.dlg.btn_load_awbm.clicked.connect(self.loadModels)
            self.dlg.btn_reset.clicked.connect(self.loadModels)

            #If the checkbox is checked/unchecked, enables/disables the associated widget
            self.dlg.chk_duration.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_runname.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_outputdir.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_outputinterval.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_wateryear.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_outputdump.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_rvhfilename.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_rvcfilename.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_rvpfilename.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_rvtfilename.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_reservoirdemandalloc.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_chunksize.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_readlivefile.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_disablehru.stateChanged.connect(self.toggleWidget)

            self.dlg.btn_addoutput.clicked.connect(lambda:customoutputs.addoutput(self))
            self.dlg.btn_rmoutput.clicked.connect(lambda:customoutputs.removeoutput(self))
           
            #Calls the function to enable/disable the spinbox for the soilmodel and the interpolation lineedit
            self.dlg.combo_soilmod.currentIndexChanged.connect(self.toggleSoilModel)
            self.dlg.combo_interpo.activated.connect(self.toggleInterpolation)

            self.dlg.btn_addhydroproc.clicked.connect(lambda:hydrologicproc.addprocess(self))
            self.dlg.btn_rmhydroproc.clicked.connect(lambda:hydrologicproc.removeprocess(self))
            self.dlg.btn_addtransport.clicked.connect(self.addTransportProc)
            self.dlg.btn_rmtransport.clicked.connect(self.rmTransportProc)
            
            #Calls the function to write the RVI file
            self.dlg.btn_write.clicked.connect(self.writeRVI)
            #----------------------------------------#

            #-------------BasinMaker RVH-------------#
            #Calls the function that toggles the proper widgets depending on the mode chosen
            self.dlg.buttonGroup.buttonToggled.connect(self.toggleWidget)   #Define project spatial extent
            self.dlg.buttonGroup_2.buttonToggled.connect(self.toggleWidget)  #Delineate routing structure without lakes
            self.dlg.file_lakes.fileChanged.connect(self.toggleWidget)  #Add lake and obs control points
            self.dlg.file_lakes.fileChanged.connect(self.loadAttributes)
            self.dlg.file_pointsinterest.fileChanged.connect(self.loadAttributes)
            self.dlg.chk_epsgcode.stateChanged.connect(self.toggleWidget)   #Enables/disables the EPSG
            self.dlg.file_bankfullwidth.fileChanged.connect(self.toggleWidget)  #Add lake and obs control points
            self.dlg.file_bankfullwidth.fileChanged.connect(self.loadAttributes)
            self.dlg.file_landuserast.fileChanged.connect(self.toggleWidget)  #Add lake and obs control points

            #Calls the function to run the docker container
            self.dlg.btn_dockerrun.clicked.connect(lambda:self.dockerinit('BasinMaker'))
            #Calls the function to remove the docker container
            self.dlg.btn_dockerrm.clicked.connect(self.docker.delete)
            #----------------------------------------#

            #----------Generate GridWeights---------#
            self.dlg.file_netcdf.fileChanged.connect(self.toggleWidget)
            self.dlg.btn_rungridweight.clicked.connect(lambda:self.dockerinit('GridWeights'))
            self.dlg.btn_rmigridweight.clicked.connect(self.docker.delete)
            #----------------------------------------#

            #---------------Stream flow---------------#
            self.dlg.btn_cehqsearch.clicked.connect(self.searchStreamflow)
            self.dlg.btn_cehqdate.clicked.connect(self.downloadStreamflow)
            self.dlg.btn_cehqdownload.clicked.connect(self.downloadStreamflow)
            self.dlg.btn_cehqlayer.clicked.connect(self.generatePointsLayer)
            self.dlg.btn_cehqprocess.clicked.connect(self.downloadStreamflow)

            self.dlg.buttonGroup_4.buttonToggled.connect(self.toggleWidget)
            self.dlg.btn_watersurveysearch.clicked.connect(self.searchStreamflow)
            self.dlg.btn_waterofficedate.clicked.connect(self.downloadStreamflow)
            self.dlg.btn_watersurveydownload.clicked.connect(self.downloadStreamflow)
            self.dlg.btn_waterofficelayer.clicked.connect(self.generatePointsLayer)
            self.dlg.btn_watersurveyprocess.clicked.connect(self.downloadStreamflow)
            #----------------------------------------#

            #---------------GIS Data ----------------#
            self.dlg.btn_downloadgisdata.clicked.connect(self.downloadGISdata)
            self.dlg.chk_samefilegis.stateChanged.connect(self.copypaths)
            self.dlg.btn_gisprocess.clicked.connect(self.processgisdata)
            #----------------------------------------#

            #-------------Run Raven Model-------------#
            self.dlg.file_runinputdir.fileChanged.connect(self.setModelname)
            self.dlg.btn_runraven.clicked.connect(self.runRaven)
            self.dlg.btn_gatheroutput.clicked.connect(self.drawHydrographs)
            self.dlg.btn_ravenview.clicked.connect(self.openRavenView)
            self.dlg.btn_fillrvptemplate.clicked.connect(self.fillRVPTemplate)
            #----------------------------------------#

            # ----------OSTRICH Calibration----------#
            self.dlg.btn_add_filepair.clicked.connect(lambda:self.ostrich.add_file_pair(self.dlg))
            self.dlg.btn_rm_filepair.clicked.connect(lambda: self.ostrich.remove_file_pair(self.dlg))
            self.dlg.btn_ost_load_params.clicked.connect(lambda: self.ostrich.load_parameters(self.dlg))
            self.dlg.btn_ost_refresh_vals.clicked.connect(lambda: self.ostrich.load_calibration_values(self.dlg))
            self.dlg.btn_ost_select_all.clicked.connect(lambda: self.ostrich.select_all(self.dlg))
            self.dlg.btn_ost_unselect_all.clicked.connect(lambda: self.ostrich.unselect_all(self.dlg))
            # ----------------------------------------#

            #----------------Settings----------------#
            self.dlg.combo_ravenexe_mode.currentIndexChanged.connect(self.toggleWidget)
            self.dlg.combo_ostrichexe_mode.currentIndexChanged.connect(self.toggleWidget)
            self.dlg.btn_savesettings.clicked.connect(self.storesettings)
            #----------------------------------------#
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()

        # See if OK was pressed
        if result:
            self.iface.messageBar().pushInfo("Info", "QRaven is already opened in another window.")
            print('The plugin is already opened in another window.' )
    

    def setupMenubar(self):
        #Sets up the left menu
            menuitems = ['Raven RVI','BasinMaker','Gridweights',
                         'Streamflow', 'GIS','Run Raven','OSTRICH','Settings']
            icons = ['rvifile.svg','basinmaker.svg','gridweights.svg',
                     'streamflow.svg','gis.svg','raven.svg','ostrich.svg','settings.svg']
            script_dir = os.path.dirname(__file__)
            for i, menuitem in enumerate(menuitems):
                icon = QIcon(os.path.join(script_dir+'/ext_data/icons/'+icons[i]))
                self.dlg.sidemenu.addItem(QListWidgetItem(icon, menuitem))
            
            self.setMenuStyle()
            #Select the first menu item
            self.dlg.sidemenu.setCurrentRow(0)

    def setMenuStyle(self):
        if self.dlg.combo_menubar.currentText() == 'Collapsed':
            self.dlg.sidemenu.setMaximumWidth(50)
            self.dlg.sidemenu.setMinimumWidth(50)
        else:
            self.dlg.sidemenu.setMaximumWidth(150)
            self.dlg.sidemenu.setMinimumWidth(150)

    #Changes the view depending on the side menu click
    def display(self, i):
        self.dlg.stackedWidget.setCurrentIndex(i)

    #This method enables and disables widgets based on their checkboxes/radiobutton state
    def toggleWidget(self):
        '''Enables/disables widgets based on the widget calling the method'''

        widget = self.dlg.sender()  #Get the widget name
        
        #Conditions for the Raven RVI section below
        if widget.objectName() == 'chk_duration':           #Enables/disables the duration and enddate widgets
            if self.dlg.chk_duration.isChecked():
                self.dlg.date_enddate.setEnabled(False)
                self.dlg.spin_duration.setEnabled(True)
            else:
                self.dlg.date_enddate.setEnabled(True)
                self.dlg.spin_duration.setEnabled(False) 
        elif widget.objectName() == 'chk_runname':          #Enables/disables the runname line edit
            if self.dlg.chk_runname.isChecked():
                self.dlg.txt_runname.setEnabled(True)
            else:
                self.dlg.txt_runname.setEnabled(False)
        elif widget.objectName() == 'chk_outputdir':        #Enables/disables the outputdirectory qgsfileedit
            if self.dlg.chk_outputdir.isChecked():
                self.dlg.file_outputdir.setEnabled(True)
            else:
                self.dlg.file_outputdir.setEnabled(False)        
        elif widget.objectName() == 'chk_outputinterval':   #Enables/disables the outputinterval spinbox
            if self.dlg.chk_outputinterval.isChecked():
                self.dlg.spin_outinterval.setEnabled(True)
            else:
                self.dlg.spin_outinterval.setEnabled(False) 
        elif widget.objectName() == 'chk_wateryear':        #Enables/disables the wateryear spinbox
            if self.dlg.chk_wateryear.isChecked():
                self.dlg.spin_wateryear.setEnabled(True)
            else:
                self.dlg.spin_wateryear.setEnabled(False) 
        elif widget.objectName() == 'chk_outputdump':
            if self.dlg.chk_outputdump.isChecked():
                self.dlg.date_outputdump.setEnabled(True)
            else:
                self.dlg.date_outputdump.setEnabled(False) 
        elif widget.objectName() == 'chk_rvhfilename':
            if self.dlg.chk_rvhfilename.isChecked():
                self.dlg.txt_rvhfilename.setEnabled(True)
            else:
                self.dlg.txt_rvhfilename.setEnabled(False) 
        elif widget.objectName() == 'chk_rvcfilename':
            if self.dlg.chk_rvcfilename.isChecked():
                self.dlg.txt_rvcfilename.setEnabled(True)
            else:
                self.dlg.txt_rvcfilename.setEnabled(False) 
        elif widget.objectName() == 'chk_rvpfilename':
            if self.dlg.chk_rvpfilename.isChecked():
                self.dlg.txt_rvpfilename.setEnabled(True)
            else:
                self.dlg.txt_rvpfilename.setEnabled(False) 
        elif widget.objectName() == 'chk_rvtfilename':
            if self.dlg.chk_rvtfilename.isChecked():
                self.dlg.txt_rvtfilename.setEnabled(True)
            else:
                self.dlg.txt_rvtfilename.setEnabled(False) 
        elif widget.objectName() == 'chk_reservoirdemandalloc':
            if self.dlg.chk_reservoirdemandalloc.isChecked():
                self.dlg.combo_reservoirdemandalloc.setEnabled(True)
            else:
                self.dlg.combo_reservoirdemandalloc.setEnabled(False) 
        elif widget.objectName() == 'chk_chunksize':
            if self.dlg.chk_chunksize.isChecked():
                self.dlg.spin_chunksize.setEnabled(True)
            else:
                self.dlg.spin_chunksize.setEnabled(False) 
        elif widget.objectName() == 'chk_readlivefile':
            if self.dlg.chk_readlivefile.isChecked():
                self.dlg.spin_readlivefile.setEnabled(True)
            else:
                self.dlg.spin_readlivefile.setEnabled(False) 
        elif widget.objectName() == 'chk_disablehru':   #Enables/disables the disable hrus text edit
            if self.dlg.chk_disablehru.isChecked():
                self.dlg.txt_disablehru.setEnabled(True)
            else:
                self.dlg.txt_disablehru.setEnabled(False)
       
        #Conditions for the BasinMaker RVH section below
        elif widget.objectName() == 'buttonGroup':  #buttonGroup is the group of radiobuttons for the mode of define project spatial extent
            if self.dlg.rb_modehybasin.isChecked(): #If the selected mode is using_hybasin
                self.dlg.file_hybasin.setEnabled(True)
                self.dlg.txt_hybasin.setEnabled(True)
                self.dlg.txt_outletlat.setEnabled(False)
                self.dlg.txt_outletlon.setEnabled(False)
                self.dlg.file_providedply.setEnabled(False)
                self.dlg.spin_buffer.setEnabled(True)
            elif self.dlg.rb_outletpt.isChecked():  #Mode is using_outlet_pt
                self.dlg.file_hybasin.setEnabled(False)
                self.dlg.txt_hybasin.setEnabled(False)
                self.dlg.txt_outletlat.setEnabled(True)
                self.dlg.txt_outletlon.setEnabled(True)
                self.dlg.file_providedply.setEnabled(False)
                self.dlg.spin_buffer.setEnabled(False)
            elif self.dlg.rb_providedply.isChecked():   #Mode is using_provided_ply
                self.dlg.file_hybasin.setEnabled(False)
                self.dlg.txt_hybasin.setEnabled(False)
                self.dlg.txt_outletlat.setEnabled(False)
                self.dlg.txt_outletlon.setEnabled(False)
                self.dlg.file_providedply.setEnabled(True)
                self.dlg.spin_buffer.setEnabled(True)
            else:
                self.dlg.file_hybasin.setEnabled(False) #Mode is using_dem
                self.dlg.txt_hybasin.setEnabled(False)
                self.dlg.txt_outletlat.setEnabled(False)
                self.dlg.txt_outletlon.setEnabled(False)
                self.dlg.file_providedply.setEnabled(False)
                self.dlg.spin_buffer.setEnabled(False)
        elif widget.objectName() == 'buttonGroup_2':  #buttonGroup_2 is the group of radiobuttons for the mode of delineate routing structure w/o lakes
            if self.dlg.rb_fdr.isChecked(): #mode is using_fdr
                self.dlg.file_fdr.setEnabled(True)
            else:
                self.dlg.file_fdr.setEnabled(False) #Mode is using_dem
        elif widget.objectName() == 'file_lakes':   #Add lake and obs control point
            if self.dlg.file_lakes.filePath() != '':   #If there is a lake layer provided, enable the fields 
                self.dlg.combo_lakeid.setEnabled(True)
                self.dlg.combo_laketype.setEnabled(True)
                self.dlg.combo_lakevol.setEnabled(True)
                self.dlg.combo_lakeavgdepth.setEnabled(True)
                self.dlg.combo_lakearea.setEnabled(True)
                self.dlg.spin_conlakearea.setEnabled(True)
                self.dlg.spin_nonconlakearea.setEnabled(True)
            else:   #If the layer is removed or there's no layer, disable the fields
                self.dlg.combo_lakeid.setEnabled(False)
                self.dlg.combo_laketype.setEnabled(False)
                self.dlg.combo_lakevol.setEnabled(False)
                self.dlg.combo_lakeavgdepth.setEnabled(False)
                self.dlg.combo_lakearea.setEnabled(False)
                self.dlg.spin_conlakearea.setEnabled(False)
                self.dlg.spin_nonconlakearea.setEnabled(False)
        elif widget.objectName() == 'chk_epsgcode':  
            if self.dlg.chk_epsgcode.isChecked():   #If the EPSG checkbox is checked, enable the EPSG line edit
                self.dlg.txt_epsgcode.setEnabled(True)
            else:
                self.dlg.txt_epsgcode.setEnabled(False)
        elif widget.objectName() == 'file_bankfullwidth':   #Add hydrology related attributes
            if self.dlg.file_bankfullwidth.filePath() != '':    #If there is a layer for bankfull width, enable the required fields
                self.dlg.combo_bankfullwidth.setEnabled(True)
                self.dlg.combo_bankfulldepth.setEnabled(True)
                self.dlg.combo_bankfulldischarge.setEnabled(True)
                self.dlg.combo_bankfulldrainarea.setEnabled(True)
                self.dlg.spin_kcoef.setEnabled(False)
                self.dlg.spin_ccoef.setEnabled(False)

            else:   #If the layer is removed or there's no layer, disable the fields
                self.dlg.combo_bankfullwidth.setEnabled(False)
                self.dlg.combo_bankfulldepth.setEnabled(False)
                self.dlg.combo_bankfulldischarge.setEnabled(False)
                self.dlg.combo_bankfulldrainarea.setEnabled(False)
                self.dlg.spin_kcoef.setEnabled(True)
                self.dlg.spin_ccoef.setEnabled(True)

        elif widget.objectName() == 'file_landuserast':   #Add hydrology related attributes
            if self.dlg.file_landuserast.filePath() != '':    #If there is a layer for landuse (raster), enable the required fields
                self.dlg.file_landusemanning.setEnabled(True)
            else:   #If the layer is removed or there's no layer, disable the fields
                self.dlg.file_landusemanning.setEnabled(False) 

        elif widget.objectName() == 'file_netcdf':
            if os.path.splitext(self.dlg.file_netcdf.filePath())[1] == '.shp':
                self.dlg.combo_ncattributes.setEnabled(True)
                self.dlg.txt_dimlon.setEnabled(False)
                self.dlg.txt_dimlat.setEnabled(False)
                self.dlg.txt_varlon.setEnabled(False)
                self.dlg.txt_varlat.setEnabled(False)
                self.loadAttributes()
            else:
                self.dlg.combo_ncattributes.setEnabled(False)
                self.dlg.txt_dimlon.setEnabled(True)
                self.dlg.txt_dimlat.setEnabled(True)
                self.dlg.txt_varlon.setEnabled(True)
                self.dlg.txt_varlat.setEnabled(True)
        elif widget.objectName() == 'buttonGroup_4':
            if self.dlg.rd_watersurveyname.isChecked():
                self.dlg.txt_watersurveyname.setEnabled(True)
                self.dlg.combo_watersurveyprovince.setEnabled(False)
            else:
                self.dlg.txt_watersurveyname.setEnabled(False)
                self.dlg.combo_watersurveyprovince.setEnabled(True)
        elif widget.objectName() == 'combo_ravenexe_mode':
            if self.dlg.combo_ravenexe_mode.currentText() != 'Executable':
                self.dlg.file_ravenexe.setEnabled(False)
            else:
                self.dlg.file_ravenexe.setEnabled(True)
        elif widget.objectName() == 'combo_ostrichexe_mode':
            if self.dlg.combo_ostrichexe_mode.currentText() != 'Executable':
                self.dlg.file_ostrichexe.setEnabled(False)
            else:
                self.dlg.file_ostrichexe.setEnabled(True)

             

    #This method enables and disables the spinbox next to the SoilModel combobox depending on the selected value of the combobox
    def toggleSoilModel(self):
        '''Toggles the spinbox for the number of soils if the soil model value is soil_multilayer'''
        if self.dlg.combo_soilmod.currentText().lower() == "soil_multilayer":
            self.dlg.spin_soilmod.setEnabled(True)
        else:
            self.dlg.spin_soilmod.setEnabled(False)


    #This method enables and disables the line edit next to the InterpolationMethod if the value is INTERP_FROM_FILE.
    def toggleInterpolation(self):
        '''Toggles the lineEdit for the interpolation file if the interpolationMethod value is inter_from_file'''
        if self.dlg.combo_interpo.currentText().lower() == "interp_from_file":
            self.dlg.txt_interpofile.setEnabled(True)
        else:
            self.dlg.txt_interpofile.setEnabled(False)


    # #This method opens a file explorer to select an output folder
    # def browseDirectory(self):
    #     '''Allows to browse the computer for a directory'''
    #     dir = str(QFileDialog.getExistingDirectory(None, "Select Directory"))
    #     self.dlg.txt_outputdir.setText(dir)
    

    def addTransportProc(self):
        typelist=['Transport','FixedConcentration','FixedTemperature','MassFlux']
        table = self.dlg.table_transport #Get the hydrologic processes table
        currentRow = table.rowCount()   #Get the number of rows the table has
        table.insertRow(currentRow) #Inserts a new row below the last row
        combo_type = QComboBox()
        txt_constituent = QLineEdit()
        combo_compartment = QComboBox()
        spin_conctemp = QDoubleSpinBox()
        combo_HRUgroup = QComboBox()


        combo_type.addItems(typelist)   #Add a combobox in the new row with all the available processes
        #txt_constituent.setEnabled(False)
        combo_compartment.setEnabled(False)
        spin_conctemp.setEnabled(False)
        combo_HRUgroup.setEnabled(False)
        table.setCellWidget(currentRow, 0, combo_type)
        table.setCellWidget(currentRow, 1, txt_constituent)
        table.setCellWidget(currentRow, 2, combo_compartment)
        table.setCellWidget(currentRow, 3, spin_conctemp)
        table.setCellWidget(currentRow, 4, combo_HRUgroup)
        table.resizeColumnsToContents() #Resizes the width of the column automatically
        combo_type.currentIndexChanged.connect(self.setTransportCommands)
    
    def setTransportCommands(self): 
        compartments = ['ATMOS_PRECIP','MULTIPLE','CANOPY','ATMOSPHERE','LAKE','SURFACE_WATER',
                          'DEPRESSION','PONDED_WATER','SNOW','SNOW_LIQ','GLACIER_ICE','GLACIER'
                       ]
        hrugroups = [x.strip() for x in self.dlg.txt_defhru.toPlainText().split(',')]
        currentWidget = self.dlg.sender()
        table = self.dlg.table_transport #Get the transport processes table
        index = self.dlg.table_transport.indexAt(currentWidget.pos())    #Get the index of the widget
        widgetRow = index.row() #Get the row in which the widget is set
        txt_constituent = QLineEdit()
        combo_compartment = QComboBox()
        spin_conctemp = QDoubleSpinBox()
        spin_conctemp.setMinimum(-99999999)
        spin_conctemp.setMaximum(99999999)
        combo_HRUgroup = QComboBox()
        combo_compartment.clear()
        combo_HRUgroup.clear()
        combo_HRUgroup.addItem("")
        if isinstance(currentWidget, QComboBox):
            selectedType = currentWidget.currentText()
            if selectedType == 'Transport':
                txt_constituent.setEnabled(True)
                combo_compartment.setEnabled(False)
                spin_conctemp.setEnabled(False)
                combo_HRUgroup.setEnabled(False)
            elif selectedType == 'FixedConcentration':
                txt_constituent.setEnabled(True)
                combo_compartment.setEnabled(True)
                combo_compartment.addItems(compartments)
                spin_conctemp.setEnabled(True)
                combo_HRUgroup.setEnabled(True)
                combo_HRUgroup.addItems(hrugroups)               
            elif selectedType == 'FixedTemperature':
                txt_constituent.setEnabled(False)
                combo_compartment.setEnabled(True)
                combo_compartment.addItems(compartments)
                spin_conctemp.setEnabled(True)
                combo_HRUgroup.setEnabled(True)
                combo_HRUgroup.addItems(hrugroups)     
            elif selectedType == 'MassFlux':
                txt_constituent.setEnabled(False)
                combo_compartment.setEnabled(True)
                combo_compartment.addItems(compartments)
                spin_conctemp.setEnabled(True)
                combo_HRUgroup.setEnabled(True)
                combo_HRUgroup.addItems(hrugroups)       
        table.setCellWidget(widgetRow, 1, txt_constituent)
        table.setCellWidget(widgetRow, 2, combo_compartment)
        table.setCellWidget(widgetRow, 3, spin_conctemp)
        table.setCellWidget(widgetRow, 4, combo_HRUgroup)

    def rmTransportProc(self):
        table = self.dlg.table_transport
        selectedRow = table.currentRow()
        table.removeRow(selectedRow)

    #This method writes all the parameters entered by the user into the RVI file
    def writeRVI(self):
        '''Gathers all the RVI parameters entered by the user from a dictionary and writes them into a .RVI file
        
            Depends on the following methods:

            getParams()

            getCustomOutput()
        '''
        paramDict = self.getParams()    #Calls the function to retrieve the widgets values
        hydroProcessesList = hydrologicproc.getHydroProcess(self)
        transportProcessesList = self.getTransportProcess()
        customOutputList = customoutputs.getOutputs(self) #Calls the function to get the custom output values
        outputdir = self.dlg.file_rvioutputdir.filePath()   #Get the output directory chosen by the use
        modelName = self.dlg.txt_modname.text()     #Get the name of the model
        disabledhrus_list = paramDict['DisableHRUGroup'].split(',')

        try:
            pathToFolder = outputdir+separator+modelName
            #Creates the RVI file with the name and path provided
            with open(pathToFolder+".rvi","w") as rvi:
                rvi.write("#".ljust(74, '=')+"#"
                          "\n# Generated by QRaven".ljust(76)+"#"+
                          "\n# Please report any issues on https://github.com/Scriptbash/QRaven/issues #\n"+
                          "#".ljust(74, '=')+"#\n\n")
                #Writes the parameters from the dictionary
                for key, value in paramDict.items():
                    if value != '' and value != "checked":  #The widget has a value and is not an optional I/O
                        if key == 'DisableHRUGroup':
                            for hru in disabledhrus_list:
                                rvi.write(f':{key:<31} {hru}\n')
                            pass
                        else:
                            rvi.write(f":{key:<30}  {value}\n")
                    elif value == "checked":   #This writes the optional I/O which don't have an argument (so only the key is written)
                        rvi.write(f":{key:<30}\n")
                
                #Writes the hydrological processes
                if not hydroProcessesList:
                    rvi.write("#:HydrologicProcesses\n#!!!Add your hydrologic processes here!!!\n#:EndHydrologicProcesses\n")
                else:
                    #processcount = 0    #Keeps tracks of the column
                    firstprocess = True #If true, means the current process is the first column
                    rvi.write(":HydrologicProcesses")
                    for process in hydroProcessesList:
                        if firstprocess == True:
                            if process == 'RedirectFlow':   #If the process is :Overflow
                                rvi.write('\n\t   :-->RedirectFlow'.ljust(30))
                                #processcount +=1
                                firstprocess = False
                            else:
                                rvi.write("\n\t{:<28}".format(':'+process)) #Else it's a regular process
                                #processcount += 1
                                firstprocess = False
                        else:   #It is an algorithm, from, to , etc.
                            if process == 'NewLine':    #If we reach the end of the list, we restart with a process
                                #processcount = 0
                                firstprocess = True
                                pass
                            elif process == 'False' or process == '':   #The process is not conditional
                                #processcount +=1
                                firstprocess = False
                                pass
                            elif process == 'condTrue': #The process is conditional
                                rvi.write('\n\t   :-->Conditional'.ljust(30))
                                #processcount += 1
                                firstprocess = False
                            elif process == 'mixTrue':
                                pass
                            elif process == 'interbasinTrue':
                                rvi.write('INTERBASIN'.ljust(30))
                            else:
                                rvi.write(' {:<20}'.format(process))
                    rvi.write("\n:EndHydrologicProcesses")
               
                #Write the transport processes
                transportCount = 0
                for transport in transportProcessesList:
                    if transportCount == 0:
                        rvi.write("\n:"+transport)
                        transportCount += 1
                    elif transportCount <= 4 and transportCount != 0:
                        rvi.write(" "+transport)
                        transportCount += 1
                    else:
                        transportCount = 1
                        rvi.write("\n:"+transport)
                
                #Write custom outputs
                if customOutputList:
                    for row in customOutputList:
                        rvi.write("\n:CustomOutput")
                        for output in row:
                            if output == '':
                                pass
                            else:
                                rvi.write(' '+output)

            print("RVI file written successfully")
            self.iface.messageBar().pushSuccess("Success", "RVI file written successfully")
        except Exception as e:
            print("Unable to write the RVI file")
            print(e)
            self.iface.messageBar().pushMessage("Error", "Unable to write the RVI file. See python logs for more details.",level=Qgis.Critical)

    #This method gathers all the RVI parameters entered by the user and returns them into a dictionary
    def getParams(self):
        '''Gets all the parameters entered by the user in the Raven RVI tab
        
            Returns a dictionary of parameters
        '''
        #Get the start date
        startDateTmp = self.dlg.date_startdate.dateTime()
        startDate = str(startDateTmp.toPyDateTime())
        #Get the end date or duration
        if self.dlg.chk_duration.isChecked():
            keyDuration = "Duration" 
            duration = str(self.dlg.spin_duration.value())
        else:
            keyDuration = "EndDate"
            endDateTmp = self.dlg.date_enddate.dateTime()
            duration = str(endDateTmp.toPyDateTime())
        #Get the time step 
        timestep_h = str("%02d" % self.dlg.spin_timestep_h.value())
        timestep_m = str("%02d" % self.dlg.spin_timestep_m.value())
        timestep_s = str("%02d" % self.dlg.spin_timestep_s.value())
        timeStep = timestep_h+':'+timestep_m+':'+timestep_s
        #Get soil model
        if self.dlg.combo_soilmod.currentText().lower() == "soil_multilayer":
            soilMod = self.dlg.combo_soilmod.currentText() + ' ' + str(self.dlg.spin_soilmod.value())
        else:
            soilMod = self.dlg.combo_soilmod.currentText()
        #Get Define HRU groups
        defHRUGroups = self.dlg.txt_defhru.toPlainText()
        #Get catchment route
        catchment = self.dlg.combo_catchment.currentText()
        #Get routing
        routing = self.dlg.combo_routing.currentText()
        #Get method
        method= self.dlg.combo_method.currentText()   
        #Get interpolation method
        if self.dlg.combo_interpo.currentText().lower() == "interp_from_file":
            interpolation = self.dlg.combo_interpo.currentText() + ' ' + self.dlg.txt_interpofile.text()
        else:
            interpolation = self.dlg.combo_interpo.currentText()
        #Get evaporation
        evaporation = self.dlg.combo_evapo.currentText()     
        #Get rain snow fraction
        rainsnowfract = self.dlg.combo_rainsnowfrac.currentText()
        #Get OW_Evaporation
        owevapo = self.dlg.combo_owevapo.currentText()
        #Get OroPrecipCorrect
        oroprecip = self.dlg.combo_oroprecip.currentText()
        #Get OroTempCorrect
        orotemp = self.dlg.combo_orotemp.currentText()
        #Get OroPetCorrect
        oropet = self.dlg.combo_oropet.currentText()
        #Get CloudCoverMethod
        cloudcover = self.dlg.combo_cloudcover.currentText()
        #Get AirPressureMethod
        airpressure = self.dlg.combo_airpressure.currentText()
        #Get PotentionMelt
        potmelt = self.dlg.combo_potentialmelt.currentText()
        #Get MonthlyInterpolationMethod
        monthlyinterpo = self.dlg.combo_monthlyinterpo.currentText()
        #Get LakeStorage
        lakestorage = self.dlg.combo_lakestorage.currentText()
        #Get SWRadiationMethod
        swradiation = self.dlg.combo_swradation.currentText()
        #Get SWCanopyCorrect
        swcanopy = self.dlg.combo_swcanopy.currentText()
        #Get SWCloudCorrect
        swcloud = self.dlg.combo_swcloud.currentText()
        #Get LWRadiationMethod
        lwradiation = self.dlg.combo_lwradation.currentText()
        #Get WindSpeedMethod
        windspeed = self.dlg.combo_windspeed.currentText()
        #Get RelativeHumidityMethod
        relhumidity = self.dlg.combo_relhumidity.currentText()
        #Get PrecipIceptFract
        precipicept = self.dlg.combo_precipicept.currentText()
        #Get RechargeMethod
        recharge = self.dlg.combo_recharge.currentText()
        #Get SubdailyMethod
        subdaily = self.dlg.combo_subdaily.currentText()
        #Get Calendar
        calendar = self.dlg.combo_calendar.currentText()
        #Get all the option IO commands
        if self.dlg.chk_runname.isChecked():
            runname = self.dlg.txt_runname.text()
        else:
            runname = ''
        if self.dlg.chk_outputdir.isChecked():
            fileoutputdir = self.dlg.file_outputdir.filePath() 
        else:
            fileoutputdir = ''
        if self.dlg.chk_outputinterval.isChecked():
            outputinterval = self.dlg.spin_outinterval.value()
        else:
            outputinterval = ''
        if self.dlg.chk_rvptemplate.isChecked():
            rvptemplate = "checked"
        else:
            rvptemplate = ''
        if self.dlg.chk_writemassbal.isChecked():
            writemassbal = "checked"
        else:
            writemassbal = ''
        if self.dlg.chk_endpause.isChecked():
            endpause = "checked"
        else:
            endpause = ''
        if self.dlg.chk_writeforcingfunc.isChecked():
            writeforcing = "checked"
        else:
            writeforcing = ''
        if self.dlg.chk_debugmode.isChecked():
            debugmode = "checked"
        else:
            debugmode = ''
        if self.dlg.chk_silentmode.isChecked():
            silentmode = "checked"
        else:
            silentmode = ''
        if self.dlg.chk_writedemand.isChecked():
            writedemand = "checked"
        else:
            writedemand = ''
        if self.dlg.chk_writeenergy.isChecked():
            writeenergy = "checked"
        else:
            writeenergy = ''
        if self.dlg.chk_writeexausmb.isChecked():
            writeexausmb = "checked"
        else:
            writeexausmb = ''
        if self.dlg.chk_writeensim.isChecked():
            writeensim = "checked"
        else:
            writeensim = ''
        if self.dlg.chk_suppressoutput.isChecked():
            suppressoutput = "checked"
        else:
            suppressoutput = ''
        if self.dlg.chk_snaphydro.isChecked():
            snaphydro = "checked"
        else:
            snaphydro = ''
        if self.dlg.chk_wateryear.isChecked():
            wateryear = self.dlg.spin_wateryear.value()
        else:
            wateryear = ''
        if self.dlg.chk_writemassloadings.isChecked():
            writemassloadings = "checked"
        else:
            writemassloadings = ''
        if self.dlg.chk_noisymode.isChecked():
            noisymode = "checked"
        else:
            noisymode = ''
        if self.dlg.chk_disablehru.isChecked():
            disabledhru = self.dlg.txt_disablehru.toPlainText()
        else:
            disabledhru = ''
        if self.dlg.chk_directevapo.isChecked():
            directevapo = "checked"
        else:
            directevapo = ''
        if self.dlg.chk_snowsuppressespet.isChecked():
            snowsuppressespet = "checked"
        else:
            snowsuppressespet = ''
        if self.dlg.chk_suppresscomppet.isChecked():
            suppresscomppet = "checked"
        else:
            suppresscomppet = ''
        if self.dlg.chk_outputdump.isChecked():
            outputdump = self.dlg.date_outputdump.dateTime()
            outputdump = str(outputdump.toPyDateTime())
        else:
            outputdump = ''
        if self.dlg.chk_rvhfilename.isChecked():
            rvhfilename = self.dlg.txt_rvhfilename.text()
        else:
            rvhfilename = ''
        if self.dlg.chk_rvcfilename.isChecked():
            rvcfilename = self.dlg.txt_rvcfilename.text()
        else:
            rvcfilename = ''
        if self.dlg.chk_rvpfilename.isChecked():
            rvpfilename = self.dlg.txt_rvpfilename.text()
        else:
            rvpfilename = ''
        if self.dlg.chk_rvtfilename.isChecked():
            rvtfilename = self.dlg.txt_rvtfilename.text()
        else:
            rvtfilename = ''
        if self.dlg.chk_reservoirdemandalloc.isChecked():
            reservoirdemandalloc = self.dlg.combo_reservoirdemandalloc.currentText()
        else:
            reservoirdemandalloc = ''
        if self.dlg.chk_chunksize.isChecked():
            chunksize = str(self.dlg.spin_chunksize.value())
        else:
            chunksize = ''
        if self.dlg.chk_readlivefile.isChecked():
            readlivefile = str(self.dlg.spin_readlivefile.value())
        else:
            readlivefile = ''
        if self.dlg.chk_usestopfile.isChecked():
            usestopfile = "checked"
        else:
            usestopfile = ''
        if self.dlg.chk_assimilatestreamflow.isChecked():
            assimilatestreamflow = 'checked'
        else:
            assimilatestreamflow = ''
        if self.dlg.chk_assimilatereservstage.isChecked():
            assimilatereservstage = 'checked'
        else:
            assimilatereservstage = ''
        

        #Writes the selected evaluation metrics
        if not self.dlg.list_evalmetrics.selectedItems(): 
            evalmetrics = ''            #If nothing is selected, assign empty text to the variable to avoid crash
        else:
            firstloop = True
            for item in self.dlg.list_evalmetrics.selectedItems():
                if firstloop != False:
                    evalmetrics = item.text()
                    firstloop = False
                else:
                    evalmetrics= evalmetrics + ' ' + item.text()

        #Create the dictionary
        paramsDict = { 
            "SilentMode"                 : silentmode,
            "NoisyMode"                  : noisymode,
            "Calendar"                   : calendar,
            "StartDate"                  : startDate,
            keyDuration                  : duration,
            "TimeStep"                   : timeStep,
            "SoilModel"                  : soilMod,
            "DefineHRUGroups"            : defHRUGroups,
            "DisableHRUGroup"            : disabledhru,
            "CatchmentRoute"             : catchment,
            "Routing"                    : routing,
            "Method"                     : method,
            "InterpolationMethod"        : interpolation,
            "Evaporation"                : evaporation,
            "RainSnowFraction"           : rainsnowfract,
            "OW_Evaporation"             : owevapo,
            "OroPrecipCorrect"           : oroprecip,
            "OroTempCorrect"             : orotemp,
            "OroPetCorrect"              : oropet,
            "CloudCoverMethod"           : cloudcover,
            "AirPressureMethod"          : airpressure,
            "PotentialMeltMethod"        : potmelt,
            "MonthlyInterpolationMethod" : monthlyinterpo,
            "LakeStorage"                : lakestorage,
            "SWRadiationMEthod"          : swradiation,
            "SWCanopyCorrect"            : swcanopy,
            "SWCloudCorrect"             : swcloud,
            "LWRadationMethod"           : lwradiation,
            "WindSpeedMethod"            : windspeed,
            "RelativeHumidityMethod"     : relhumidity,
            "PrecipIceptFract"           : precipicept,
            "RechargeMethod"             : recharge,
            "SubdailyMethod"             : subdaily,
            "DirectEvaporation"          : directevapo,
            "SnowSuppressesPET"          : snowsuppressespet,
            "SuppressCompetitivePET"     : suppresscomppet,
            "RunName"                    : runname,
            "OutputDirectory"            : fileoutputdir,
            "OutputInterval"             : outputinterval,
            "CreateRVPTemplate"          : rvptemplate,
            "WaterYearStartMonth"        : wateryear,
            "OutputDump"                 : outputdump,
            "rvh_filename"               : rvhfilename,
            "rvc_filename"               : rvcfilename,
            "rvp_filename"               : rvpfilename,
            "rvt_filename"               : rvtfilename,
            "ReservoirDemandAllocation"  : reservoirdemandalloc,
            "Chunksize"                  : chunksize,
            "ReadLiveFile"               : readlivefile,
            "WriteMassBalanceFile"       : writemassbal,
            "writeForcingFunctions"      : writeforcing,
            "EndPause"                   : endpause,
            "DebugMode"                  : debugmode,
            "WriteDemandFile"            : writedemand,
            "WriteEnergyStorage"         : writeenergy,
            "WriteExhaustiveMB"          : writeexausmb,
            "WriteEnsimFormat"           : writeensim,
            "WriteMassLoadings"          : writemassloadings,
            "SuppressOutput"             : suppressoutput,
            "SnapshotHydrograph"         : snaphydro,
            "UseStopFile"                : usestopfile,
            "AssimilateStreamflow"       : assimilatestreamflow,
            "AssimilateReservoirStage"   : assimilatereservstage,
            "EvaluationMetrics"          : evalmetrics
        }
        return paramsDict


    def getTransportProcess(self):
        table = self.dlg.table_transport
        rows = table.rowCount()
        cols = table.columnCount()
        processesList = []

        for row in range(rows):
            for col in range(cols):
                currentWidget = table.cellWidget(row,col)
                if isinstance(currentWidget, QComboBox):
                    processesList.append(currentWidget.currentText())
                elif isinstance(currentWidget,QLineEdit):
                    processesList.append(currentWidget.text())
                elif isinstance(currentWidget,QDoubleSpinBox):
                    if currentWidget.isEnabled():
                        processesList.append(str(currentWidget.value()))
                    else:
                        processesList.append("")        
        return processesList

    #This method gets all the RVH parameters and returns them into a dictionary
    def getRVHparams(self):
        '''Gathers all the values entered by the user inside the BasinMaker RVH tab
        
            Returns a dictionary of parameters
        '''
        pathdem = self.dlg.file_dem.filePath()  #Get the path to the DEM
        pathlandusepoly = self.dlg.file_landusepoly.filePath()  #Get the path to the landuse polygon
        pathlanduserast = self.dlg.file_landuserast.filePath()  #Get the path to the landuse raster
        if pathlanduserast =='':
            pathlanduserast = '#'
        pathlakes = self.dlg.file_lakes.filePath()  #Get the path to the lakes polygon
        if pathlakes == '': #Since the lakes are optional, assign a value so the parameter is still written. 
            pathlakes = '#' #This allows to make a check in the create_RVH.py
        pathbankfull = self.dlg.file_bankfullwidth.filePath()   #Get the path to the bankfull width file
        if pathbankfull == '':
            pathbankfull = '#'
        pathsoil = self.dlg.file_soil.filePath()    #Get the path to the soil file
        pathpointsinterest = self.dlg.file_pointsinterest.filePath()    #Get the path to the points of interest file
        maxmemory = self.dlg.spin_ram.value()   #Get the max RAM for BasinMaker to use
        
        if self.dlg.rb_modedem.isChecked(): #If the mode using_DEM
            extentMode = "using_dem"
            path_hybasin = ''
            hybasinid = ''
            bufferdistance = ''
            outletlat = ''
            outletlon = ''
            path_providedpoly = ''
        elif self.dlg.rb_modehybasin.isChecked():   #If the mode is using_hybasin
            extentMode = "using_hybasin"
            path_hybasin = self.dlg.file_hybasin.filePath()
            hybasinid   = str(self.dlg.txt_hybasin.text())
            bufferdistance = str(self.dlg.spin_buffer.value())
            outletlat = ''
            outletlon = ''
            path_providedpoly = ''
        elif self.dlg.rb_outletpt.isChecked():  #If the mode is using_outlet_pt
            extentMode = "using_outlet_pt"
            outletlat = self.dlg.txt_outletlat.text()
            outletlon = self.dlg.txt_outletlon.text()
            path_hybasin = ''
            hybasinid = ''
            bufferdistance = ''
            path_providedpoly = ''
        elif self.dlg.rb_providedply.isChecked():   #If the mode is using_provided_ply
            extentMode = "using_provided_ply"
            path_providedpoly = self.dlg.file_providedply.filePath()
            bufferdistance = str(self.dlg.spin_buffer.value())
            path_hybasin = ''
            hybasinid = ''
            outletlat = ''
            outletlon = ''
        
        if self.dlg.file_lakes.filePath():    #If there is a layer for the lakes, gather the values needed. Else, assign empty values
            lakeid = self.dlg.combo_lakeid.currentText()
            laketype = self.dlg.combo_laketype.currentText()
            lakevol = self.dlg.combo_lakevol.currentText()
            lakeavgdepth = self.dlg.combo_lakeavgdepth.currentText()
            lakearea = self.dlg.combo_lakearea.currentText()
            connectedlake = self.dlg.spin_conlakearea.value()
            nonconnectedlake = self.dlg.spin_nonconlakearea.value()
            print('went in the non empty values')
        else:
            lakeid = '#'
            laketype = '#'
            lakevol = '#'
            lakeavgdepth = '#'
            lakearea = '#'
            connectedlake = '#'
            nonconnectedlake = '#'

        poiid = self.dlg.combo_poiid.currentText()   #Get the id field of the point of interest
        poiname = self.dlg.combo_poiname.currentText()   #Get the name field of the point of interest
        poidrainarea = self.dlg.combo_poidrainarea.currentText() #Get the drainage area field of the point of interest
        poisource = self.dlg.combo_poisource.currentText()   #Get the source field of the point of interest

        if self.dlg.chk_epsgcode.isChecked():   #Get the EPSG code if the checkbox is checkedm
            epsgcode = 'EPSG:'+self.dlg.txt_epsgcode.text()
        else:                                   #Otherwise use the default value of BasinMaker
            epsgcode = 'EPSG:3573'

        if self.dlg.file_bankfullwidth.filePath():  #If there is a layer for Bankfull width, gather the values needed
            bankfullwidth = self.dlg.combo_bankfullwidth.currentText()
            bankfulldepth = self.dlg.combo_bankfulldepth.currentText()
            bankfulldischarge = self.dlg.combo_bankfulldischarge.currentText()
            bankfulldrainage = self.dlg.combo_bankfulldrainarea.currentText()
            kcoef = ''
            ccoef = ''
        else:  
            bankfullwidth = ''
            bankfulldepth = ''
            bankfulldischarge = ''
            bankfulldrainage = ''
            kcoef = str(self.dlg.spin_kcoef.value())
            ccoef = str(self.dlg.spin_ccoef.value())

        if self.dlg.file_landuserast.filePath():    #If a landuse raster is provided, get its path
            landusemanning = self.dlg.file_landusemanning.filePath()
        else:
            landusemanning = '#'
        if self.dlg.rb_fdr.isChecked():  #If the delineation mode is using_fdr, get the flow direction file path
            delineatemode = "using_fdr"
            pathfdr = self.dlg.file_fdr.filePath()
        elif self.dlg.rb_dem.isChecked(): #If the delineation mode is using_dem, assign an empty value to the fdr path
            delineatemode = "using_dem"
            pathfdr = ''
        facthreshold = self.dlg.spin_facthreshold.value()   #Get the flow accumulation threshold value
        
        #Postprocessing parameters
        filterconnectedlakes = self.dlg.spin_filterconnectedlakes.value()  #Get the connected lake area threshold value
        filternonconnectedlakes = self.dlg.spin_filternonconnectedlakes.value() #Get the non connected lake area threshold value
        if self.dlg.txt_selectedlakeid.text() != '':    #Get selected lake ids if they are provided
            selectedlakeid = self.dlg.txt_selectedlakeid.text().replace(" ","")
        else:
            selectedlakeid = '#'
        minsubbasinarea = self.dlg.spin_minsubbasinarea.value() #Get the minimum subbasin area value
        pathlanduseinfo = self.dlg.file_pathlanduseinfo.filePath()  #Get the landuse csv file path
        pathsoilinfo = self.dlg.file_pathsoilinfo.filePath()    #Get the soil csv file path
        pathveginfo = self.dlg.file_pathveginfo.filePath()  #Get the vegetation csv file path
        modelname = self.dlg.txt_modelname.text()   #Get the name of the model

        #Create the RVH parameters dictionary
        params = {
            "pathdem"                   : pathdem,
            "pathlandusepoly"           : pathlandusepoly,
            "pathlanduserast"           : pathlanduserast,
            "pathlakes"                 : pathlakes,
            "pathbankfull"              : pathbankfull,
            "pathsoil"                  : pathsoil,
            "pathpointsinterest"        : pathpointsinterest,
            "maxmemory"                 : maxmemory,
            "extentmode"                : extentMode,
            "pathhybasin"               : path_hybasin,
            "hybasinid"                 : hybasinid,
            "bufferdistance"            : bufferdistance,
            "outletlat"                 : outletlat,
            "outletlon"                 : outletlon,
            "path_providedpoly"         : path_providedpoly,
            "lakeid"                    : lakeid,
            "laketype"                  : laketype,
            "lakevol"                   : lakevol,
            "lakeavgdepth"              : lakeavgdepth,
            "lakearea"                  : lakearea,
            "connectedlake"             : connectedlake,
            "nonconnectedlake"          : nonconnectedlake,
            "poiid"                     : poiid,
            "poiname"                   : poiname,
            "poidrainarea"              : poidrainarea,
            "poisource"                 : poisource,
            "epsgcode"                  : epsgcode,
            "bankfullwidth"             : bankfullwidth,
            "bankfulldepth"             : bankfulldepth,
            "bankfulldischarge"         : bankfulldischarge,
            "bankfulldrainage"          : bankfulldrainage,
            "kcoef"                     : kcoef,
            "ccoef"                     : ccoef,
            "landusemanning"            : landusemanning,
            "facthreshold"              : facthreshold,
            "delineatemode"             : delineatemode,
            "pathfdr"                   : pathfdr,
            "filterconnectedlakes"      : filterconnectedlakes,
            "filternonconnectedlakes"   : filternonconnectedlakes,
            "selectedlakeid"            : selectedlakeid,
            "minsubbasinarea"           : minsubbasinarea,
            "pathlanduseinfo"           : pathlanduseinfo,
            "pathsoilinfo"              : pathsoilinfo,
            "pathveginfo"               : pathveginfo,
            "modelname"                 : modelname
        }
        return params

    #This method exports the paramters dictionary into a file. This file is then used by the docker container
    #to run BasinMaker using the parameters from the file
    def exportRVHparams(self,paramDict):
        '''Exports the RVH parameters dictionary into a .txt file stored inside a directory provided by the user'''
        outputdir = self.dlg.file_outputfolder.filePath()   #Get the output directory
        try:
            #Path where to save the parameters file
            pathToFolder = outputdir+separator+ "parameters"
            #Creates the rvh parameters file with path provided
            with open(pathToFolder+".txt","w") as file:
                #Writes the parameters from the dictionary
                for key, value in paramDict.items():
                    if value != '':
                        file.write(f"{key:<30}  {value}\n")
            print("Export .rvh parameters - Success.")
        except Exception as e:
            print("Export .rvh parameters - Failed.")
            print(e)


    def loadAttributes(self):
        widget = self.dlg.sender()
        widgetname = widget.objectName()
        if widgetname == 'file_lakes': 
            lakespath = self.dlg.file_lakes.filePath()
            vlayer = QgsVectorLayer(lakespath, "lakes", "ogr")
            if not vlayer.isValid():
                print("Layer failed to load!")
            else:
                field_names = vlayer.fields().names()
                self.dlg.combo_lakeid.clear()
                self.dlg.combo_lakeid.addItem('LAKE ID - required')
                self.dlg.combo_lakeid.addItems(field_names)
                self.dlg.combo_laketype.clear()
                self.dlg.combo_laketype.addItem('LAKE TYPE')
                self.dlg.combo_laketype.addItems(field_names)
                self.dlg.combo_lakeavgdepth.clear()
                self.dlg.combo_lakeavgdepth.addItem('AVERAGE DEPTH (m)')
                self.dlg.combo_lakeavgdepth.addItems(field_names)
                self.dlg.combo_lakearea.clear()
                self.dlg.combo_lakearea.addItem('AREA OF LAKES (km2) - required')
                self.dlg.combo_lakearea.addItems(field_names)
                self.dlg.combo_lakevol.clear()
                self.dlg.combo_lakevol.addItem('VOLUME OF LAKES (km3) - required')
                self.dlg.combo_lakevol.addItems(field_names)
        elif widgetname == 'file_pointsinterest':
            poipath = self.dlg.file_pointsinterest.filePath()
            vlayer = QgsVectorLayer(poipath, "poi", "ogr")
            if not vlayer.isValid():
                print("Layer failed to load!")
            else:
                field_names = vlayer.fields().names()
                self.dlg.combo_poiid.clear()
                self.dlg.combo_poiid.addItem('ID - required')
                self.dlg.combo_poiid.addItems(field_names)
                self.dlg.combo_poiname.clear()
                self.dlg.combo_poiname.addItem('UNIQUE NAME')
                self.dlg.combo_poiname.addItems(field_names)
                self.dlg.combo_poidrainarea.clear()
                self.dlg.combo_poidrainarea.addItem('DRAINAGE AREA - required')
                self.dlg.combo_poidrainarea.addItems(field_names)
                self.dlg.combo_poisource.clear()
                self.dlg.combo_poisource.addItem('SOURCE OF OBSERVATION')
                self.dlg.combo_poisource.addItems(field_names)      
        elif widgetname == 'file_bankfullwidth':
            bankfullpath = self.dlg.file_bankfullwidth.filePath()
            vlayer = QgsVectorLayer(bankfullpath, "bkfw", "ogr")
            if not vlayer.isValid():
                print("Layer failed to load!")
            else:
                field_names = vlayer.fields().names()
                self.dlg.combo_bankfullwidth.clear()
                self.dlg.combo_bankfullwidth.addItem('BANKFULL WIDTH (m) - required')
                self.dlg.combo_bankfullwidth.addItems(field_names)
                self.dlg.combo_bankfulldepth.clear()
                self.dlg.combo_bankfulldepth.addItem('BANKFULL DEPTH (m) - required')
                self.dlg.combo_bankfulldepth.addItems(field_names)
                self.dlg.combo_bankfulldischarge.clear()
                self.dlg.combo_bankfulldischarge.addItem('ANNUAL MEAN DISCHARGE (m3/s) - required')
                self.dlg.combo_bankfulldischarge.addItems(field_names)
                self.dlg.combo_bankfulldrainarea.clear()
                self.dlg.combo_bankfulldrainarea.addItem('DRAINAGE AREA (km2) - required')
                self.dlg.combo_bankfulldrainarea.addItems(field_names)   


        elif widgetname == 'file_netcdf':
            netcdfpath = self.dlg.file_netcdf.filePath()
            vlayer = QgsVectorLayer(netcdfpath, "netcdf", "ogr")
            if not vlayer.isValid():
                print("Layer failed to load!")
            else:
                field_names = vlayer.fields().names()
                self.dlg.combo_ncattributes.clear()
                self.dlg.combo_ncattributes.addItems(field_names)             
            
    #This method sets up the scriptbash/basinmaker docker container. Pulls, starts and stops the docker container
    def dockerinit(self, mode):
        '''Runs multiple methods related to Docker. Basically manages the Docker setup
        
            Depends on the following methods:

            getRVHparams() exportRVHparams() dockerPull() dockerStart()

            dockerCopy() runBasinMaker() getDockerResults()
         '''
    
        pythonConsole = self.iface.mainWindow().findChild(QDockWidget, 'PythonConsole')
        if not pythonConsole or not pythonConsole.isVisible():  #If the python console is closed, open it
            self.iface.actionShowPythonDialog().trigger()       #It allows the user to see the BasinMaker progress
        self.iface.mainWindow().repaint()

        if self.containerization == 'Docker':
            if computerOS == 'macos':
                os.environ["PATH"] = "/Applications/Docker.app/Contents/Resources/bin" #This is needed for docker to work on MacOS
            elif computerOS == 'windows':
                os.environ["PATH"] = "C:\\Program Files\\Docker\\Docker\\resources\\bin"    #This is needed so that the docker commands work on Windows
        elif self.containerization == 'Podman':
            if computerOS == 'macos':
                os.environ["PATH"] = "/opt/podman/bin"
            elif computerOS == 'windows':
                os.environ["PATH"] = "C:\\Program Files\\RedHat\\Podman"

        self.docker.pull()
        
        if mode == 'BasinMaker':
            self.iface.messageBar().pushInfo("Info", "The BasinMaker process is starting, this will take a while to complete.")
            outputdir = self.dlg.file_outputfolder.filePath()
            paramsDict = self.getRVHparams()    #Calls the function to get the RVH parameters
            self.exportRVHparams(paramsDict)    #Calls the function to export the RVH parameters into a file
            self.docker.start('/root/BasinMaker', None, None)
            self.docker.bmCopy(paramsDict, outputdir)
            self.docker.runBasinMaker()
            self.docker.getBasinMakerResults(outputdir)
        elif mode == 'GridWeights':
            ncfile = self.dlg.file_netcdf.filePath()
            ncfilename = ntpath.basename(ncfile)  #Get the file name with extension
            foldernc = os.path.dirname(ncfile)  #Get only the file path (without the file name)
            ncextension = os.path.splitext(ncfilename)[1]
            volumenc = foldernc+':/root/Gridweights/Data/'
            hrusfile = self.dlg.file_hrus.filePath()
            hrusfilename = ntpath.basename(hrusfile)
            folderhrus = os.path.dirname(hrusfile)
            volumehrus = folderhrus+':/root/Gridweights/Data/'
            dimlon = self.dlg.txt_dimlon.text()
            dimlat = self.dlg.txt_dimlat.text()
            varlon = self.dlg.txt_varlon.text()
            varlat = self.dlg.txt_varlat.text()
            subgauge_id = self.dlg.txt_gridid.text()
            output = self.dlg.file_outputgridweight.filePath()
            outputfolder = folderhrus = os.path.dirname(output)
            outputfile = ntpath.basename(output)

            if self.dlg.rb_subbasinid.isChecked():
                selectedid = ' -s '
            elif self.dlg.rb_gaugeid.isChecked():
                selectedid = ' -b '
            if ncextension == '.shp':
                shpattributes = self.dlg.combo_ncattributes.currentText()
                pythoncmd = 'python3 -u derive_grid_weights.py -i ' + '/root/Gridweights/Data/'+ncfilename + ' -f '+ '"'+shpattributes+'"' + ' -r ' + '/root/Gridweights/hru/' + hrusfilename + selectedid + ' ' + subgauge_id + ' -o ' + '/root/Gridweights/'+outputfile #Bash command to start the Gridweights script
            else:
                pythoncmd = 'python3 -u derive_grid_weights.py -i ' + '/root/Gridweights/Data/'+ncfilename + ' -d ' + '"'+dimlon+','+dimlat+'"' + ' -v ' + '"'+varlon+','+varlat+'"' +' -r ' + '/root/Gridweights/hru/' + hrusfilename + selectedid + ' ' + subgauge_id + ' -o ' + '/root/Gridweights/'+outputfile #Bash command to start the Gridweights script
    
            self.docker.start('/root/Gridweights', volumenc, volumehrus)
            self.docker.runGridWeights(pythoncmd)
            self.docker.getGridWeightsResults(outputfile, outputfolder)
        
        self.docker.stop()

    # #This method runs the gridweight generator inside the Docker container
    # def generateGridWeights(self):
        
    #     ncfile = self.dlg.file_netcdf.filePath()
    #     ncfilename = ntpath.basename(ncfile)  #Get the file name with extension
    #     foldernc = os.path.dirname(ncfile)  #Get only the file path (without the file name)
    #     ncextension = os.path.splitext(ncfilename)[1]
    #     volumenc = foldernc+':/root/Gridweights/nc/'
    #     hrusfile = self.dlg.file_hrus.filePath()
    #     hrusfilename = ntpath.basename(hrusfile)
    #     folderhrus = os.path.dirname(hrusfile)
    #     volumehrus = folderhrus+':/root/Gridweights/hru/'
    #     dimlon = self.dlg.txt_dimlon.text()
    #     dimlat = self.dlg.txt_dimlat.text()
    #     varlon = self.dlg.txt_varlon.text()
    #     varlat = self.dlg.txt_varlat.text()
    #     subgauge_id = self.dlg.txt_gridid.text()
    #     output = self.dlg.file_outputgridweight.filePath()
    #     outputfolder = folderhrus = os.path.dirname(output)
    #     outputfile = ntpath.basename(output)
    #     containerization = self.dlg.combo_container.currentText() #Get the preferred containerization software
    #     containerimage = self.dlg.combo_dockerimage.currentText() #Get the image 

    #     if containerization == 'Docker':
    #         contnrCMD = 'docker'
    #         if computerOS == 'macos':
    #             os.environ["PATH"] = "/Applications/Docker.app/Contents/Resources/bin" #This is needed for docker to work on MacOS
    #         elif computerOS == 'windows':
    #             os.environ["PATH"] = "C:\\Program Files\\Docker\\Docker\\resources\\bin"    #This is needed so that the docker commands work on Windows
    #     elif containerization == 'Podman':
    #         contnrCMD = 'podman'
    #         if computerOS == 'macos':
    #             os.environ["PATH"] = "/opt/podman/bin"
    #         elif computerOS == 'windows':
    #             os.environ["PATH"] = "C:\\Program Files\\RedHat\\Podman"

    #     if self.dlg.rb_subbasinid.isChecked():
    #         selectedid = ' -s '
    #     elif self.dlg.rb_gaugeid.isChecked():
    #         selectedid = ' -b '                    
        
    #     pythonConsole = self.iface.mainWindow().findChild(QDockWidget, 'PythonConsole')
    #     if not pythonConsole or not pythonConsole.isVisible():  #If the python console is closed, open it
    #         self.iface.actionShowPythonDialog().trigger()
    #     self.iface.messageBar().pushInfo("Info", "The GridWeights generator process has started. This could take a while.")
    #     self.iface.mainWindow().repaint()
    #     docker.dockerPull(computerOS)                   #Calls the function to pull the container
    #     try:
    #         print("Attempting to start the container...")
    #         cmd=contnrCMD, 'run', '-t', '-d','-w','/root/BasinMaker','-v', volumenc , '-v', volumehrus, '--name', 'qraven', containerimage
    #         docker.dockerCommand(cmd, computerOS)
        
    #         print("The container was started successfully")
    #     except Exception as e:
    #         print(e)
    #     print("Starting the GridWeights generator process, this will take a while to complete")
    #     if ncextension == '.shp':
    #         shpattributes = self.dlg.combo_ncattributes.currentText()
    #         pythoncmd = 'python3 -u ~/Gridweights/derive_grid_weights.py -i ' + '/root/Gridweights/nc/'+ncfilename + ' -f '+ '"'+shpattributes+'"' + ' -r ' + '/root/Gridweights/hru/' + hrusfilename + selectedid + ' ' + subgauge_id + ' -o ' + '/root/Gridweights/'+outputfile #Bash command to start the Gridweights script
            
    #     else:
    #         pythoncmd = 'python3 -u ~/Gridweights/derive_grid_weights.py -i ' + '/root/Gridweights/nc/'+ncfilename + ' -d ' + '"'+dimlon+','+dimlat+'"' + ' -v ' + '"'+varlon+','+varlat+'"' +' -r ' + '/root/Gridweights/hru/' + hrusfilename + selectedid + ' ' + subgauge_id + ' -o ' + '/root/Gridweights/'+outputfile #Bash command to start the Gridweights script
    #     print(pythoncmd)
    #     cmd =containerization, 'exec','-t', 'qraven','/bin/bash','-i','-c',pythoncmd    #Docker command to run the script
    #     try:
    #         os.system(contnrCMD+" start qraven")    #Make sure the container is started. Only needed when the plugin is run a second time
    #         docker.dockerCommand(cmd, computerOS)
    #         cmd = contnrCMD, 'cp', 'qraven:/root/Gridweights/'+outputfile, outputfolder
    #         docker.dockerCommand(cmd, computerOS)
    #         print("GridWeights generator has finished processing the files")  
    #     except Exception as e:
    #         print("The GridWeights generator process failed...")
    #         print(e)
    #     self.iface.messageBar().pushInfo("Info", "The GridWeights generator process has finished. Check the python logs for more details.")
    #     docker.dockerStop()
   
    def searchStreamflow(self):
        widget = self.dlg.sender().objectName()  #Get the widget name

        #----CEHQ---#
        if widget == 'btn_cehqsearch':
            self.dlg.txt_cehqresults.clear()
            city = self.dlg.combo_cehqmunicipality.currentText()
            river = self.dlg.combo_cehqriver.currentText()
            region = self.dlg.combo_cehqadminregion.currentText()

            parser = streamflow.MyHTMLParser()

            html = streamflow.cehq.sendRequest(city,river,region)
            parser.feed(html)
            data= parser.data
            stations = streamflow.cehq.parseTable(data)
            if not stations:
                self.dlg.txt_cehqresults.appendPlainText('No stations found.')
            else:
                for line in stations:
                    isId = True
                    text = ''
                    for info in line:
                        if isId:
                            text += info.strip()+' - | '
                            isId = False
                        else:
                            text+= info.strip()+' | '
                    text+='\n'
                    self.dlg.txt_cehqresults.appendPlainText(text)
        #----Water office----#
        elif widget == 'btn_watersurveysearch':
            self.dlg.txt_watersurveyresults.clear()
            if self.dlg.rd_watersurveyname.isChecked() and self.dlg.txt_watersurveyname.text() !='':
                search_type = 'station_name'
                value = self.dlg.txt_watersurveyname.text()
            else:
                watersurvey_provinces= {'All Provinces':'all',
                                    'Alberta':'AB',
                                    'British Columbia':'BC',
                                    'Manitoba':'MB',
                                    'New Brunswick':'NB',
                                    'Newfoundland and Labrador':'NL',
                                    'Northwest Territories':'NT',
                                    'Nova Scotia':'NS',
                                    'Nunavut':'NU',
                                    'Ontario':'ON',
                                    'Prince Edward Island':'PE',
                                    'Quebec':'QC',
                                    'Saskatchewan':'SK',
                                    'Yukon':'YT',
                                }
                search_type = 'province'
                value = self.dlg.combo_watersurveyprovince.currentText()
                value = watersurvey_provinces[value]
            regulation = self.dlg.combo_watersurveyregul.currentText()
            
            if regulation == 'All':
                regulation = 'all'
            elif regulation == 'Regulated':
                regulation = 'R'
            else:
                regulation = 'N'
            status = self.dlg.combo_watersurveystatus.currentText()
            if status == 'All':
                status = 'all'
            elif status == 'Active':
                status = 'A'
            else:
                status = 'D'

            parser = streamflow.MyHTMLParser()

            html = streamflow.watersurvey.sendRequest(search_type,value,regulation,status)
            parser.feed(html)
            data= parser.data
            self.waterofficestations = streamflow.watersurvey.parseTable(data)
            
            if not self.waterofficestations:
                self.dlg.txt_watersurveyresults.appendPlainText('No stations found.')
            else:
                tmpstation = self.waterofficestations.copy()
                for line in tmpstation:
                    line = line.copy()
                    del line[-3:]   #Removes unecessary info
                    isId = True
                    text = ''
                    for info in line:
                        if isId:
                            text += info.strip()+' - | '
                            isId = False
                        else:
                            text+= info.strip()+' | '
                    text+='\n'
                    self.dlg.txt_watersurveyresults.appendPlainText(text)
        

    def downloadStreamflow(self):
        widget = self.dlg.sender().objectName()  #Get the widget name
        #----CEHQ----#
        if widget == 'btn_cehqdate':
            id = self.dlg.txt_cehqid.text().strip()
            if id:
                try:
                    streamflowdata = streamflow.cehq.downloadData(id)
                    self.observation, self.stationinfo = streamflow.cehq.extractData(streamflowdata,id)
                    startdate = QtCore.QDate.fromString(self.observation[0][1], "yyyy/MM/dd")
                    enddate = QtCore.QDate.fromString(self.observation[-1][1], "yyyy/MM/dd")

                    self.dlg.date_cehqstartdate.setMinimumDate(startdate)
                    self.dlg.date_cehqstartdate.setMaximumDate(enddate)
                    self.dlg.date_cehqstartdate.setDate(startdate)
                    self.dlg.date_cehqenddate.setMinimumDate(startdate)
                    self.dlg.date_cehqenddate.setMaximumDate(enddate)
                    self.dlg.date_cehqenddate.setDate(enddate)

                    self.dlg.btn_cehqdownload.setEnabled(True)
                except Exception as e:
                    self.iface.messageBar().pushMessage("Couldn't download the data. Please verify the station ID and dates",level=Qgis.Critical)
                    print(e)
            else:
                self.iface.messageBar().pushMessage("A station ID is required.",level=Qgis.Critical)
        elif widget == 'btn_cehqdownload':
            id = self.dlg.txt_cehqid.text().strip()
            startdate = self.dlg.date_cehqstartdate.date().toPyDate()
            enddate = self.dlg.date_cehqenddate.date().toPyDate()
            output = self.dlg.file_cehqoutput.filePath()
            if id and output:
                try:
                    streamflow.cehq.exportRVT(self.observation,output,'web',startdate,enddate)
                    self.iface.messageBar().pushSuccess("Success", "RVT file written successfully")
                    self.dlg.txt_cehqidlist.appendPlainText(str(self.stationinfo))
                    self.stations.append(self.stationinfo)
                    self.dlg.txt_cehqid.clear()
                    self.dlg.btn_cehqdownload.setEnabled(False)
                    self.dlg.btn_cehqlayer.setEnabled(True)
                except Exception as e:
                    self.iface.messageBar().pushMessage("Couldn't download the data. Please verify the station ID and dates",level=Qgis.Critical)
                    print(e)
            else:
                self.iface.messageBar().pushMessage("A station ID and an output file are required.",level=Qgis.Critical)
        elif widget == 'btn_cehqprocess':
            startdate = self.dlg.date_cehqstartdate.date().toPyDate()
            enddate = self.dlg.date_cehqenddate.date().toPyDate()
            streamflowpath = self.dlg.file_cehqlocalinput.filePath()
            output = self.dlg.file_cehqlocaloutput.filePath()
            if streamflowpath and output:
                try:
                    streamflow.cehq.exportRVT(streamflowpath,output,'local',startdate,enddate)
                    self.iface.messageBar().pushSuccess("Success", "RVT file written successfully")
                except Exception as e:
                    self.iface.messageBar().pushMessage("Couldn't process the file. Please verify the input file",level=Qgis.Critical)
                    print(e)
            else:
                self.iface.messageBar().pushMessage("An input and output file are required.",level=Qgis.Critical)
        
        #-----Water office----#
        elif widget == 'btn_waterofficedate':
            id = self.dlg.txt_watersurveyid.text().strip()
            if id:
                self.streamflowdata = streamflow.watersurvey.downloadData(id)
                startdate, enddate = streamflow.watersurvey.fetchDates(self.streamflowdata)
                startdate = QtCore.QDate.fromString(startdate, "yyyy/MM/dd")
                enddate = QtCore.QDate.fromString(enddate, "yyyy/MM/dd")

                self.dlg.date_watersurveystartdate.setMinimumDate(startdate)
                self.dlg.date_watersurveystartdate.setMaximumDate(enddate)
                self.dlg.date_watersurveystartdate.setDate(startdate)
                self.dlg.date_watersurveyenddate.setMinimumDate(startdate)
                self.dlg.date_watersurveyenddate.setMaximumDate(enddate)
                self.dlg.date_watersurveyenddate.setDate(enddate)

                self.dlg.btn_watersurveydownload.setEnabled(True)

        elif widget == 'btn_watersurveydownload':
            id = self.dlg.txt_watersurveyid.text().strip()
            startdate = self.dlg.date_watersurveystartdate.date().toPyDate()
            enddate = self.dlg.date_watersurveyenddate.date().toPyDate()
            output = self.dlg.file_watersurveyoutput.filePath()

            if id and output:
                try: 
                    streamflow.watersurvey.exportRVT(self.streamflowdata,output,startdate,enddate)
                    self.iface.messageBar().pushSuccess("Success", "RVT file written successfully")
                    stationinfo = [station for station in self.waterofficestations if station[0] == id]
                    if not stationinfo[0][-1]:
                        stationinfo[0][-1] = '-9999'

                    stationinfo = [stationinfo[0][0],stationinfo[0][-3],stationinfo[0][-2],stationinfo[0][-1]]
                    self.stations.append(stationinfo)
                    self.dlg.txt_waterofficeidlist.appendPlainText(str(stationinfo))
                    self.dlg.txt_watersurveyid.clear()
                    self.dlg.btn_watersurveydownload.setEnabled(False)
                    self.dlg.btn_waterofficelayer.setEnabled(True)
                    
                except Exception as e:
                    self.iface.messageBar().pushMessage("Couldn't download the data. Please verify the station ID",level=Qgis.Critical)
                    print(e)
            else:
                self.iface.messageBar().pushMessage("A station ID and an output file are required.",level=Qgis.Critical)
        elif widget == 'btn_watersurveyprocess':
            startdate = self.dlg.date_watersurveystartdate.date().toPyDate()
            enddate = self.dlg.date_watersurveyenddate.date().toPyDate()
            streamflowpath = self.dlg.file_watersurveylocalinput.filePath()
            output = self.dlg.file_watersurveylocaloutput.filePath()
            if streamflowpath and output:
                try:
                    with open(streamflowpath,'r') as file:
                        streamflowdata = file.read()
                        streamflow.watersurvey.exportRVT(streamflowdata,output,startdate,enddate)
                    self.iface.messageBar().pushSuccess("Success", "RVT file written successfully")
                except Exception as e:
                    self.iface.messageBar().pushMessage("Couldn't process the file. Please verify the input file",level=Qgis.Critical)
                    print(e)
            else:
                self.iface.messageBar().pushMessage("An input and output file are required.",level=Qgis.Critical)

    def generatePointsLayer(self):
        stations = self.stations

        #Creates layer
        vl = QgsVectorLayer("Point", "qrvn_stations", "memory")
        pr = vl.dataProvider()

        #Adds fields
        pr.addAttributes([
            QgsField("id", QVariant.Int),
            QgsField("name", QVariant.String),
            QgsField("drain_area", QVariant.Double),
            QgsField("source", QVariant.String)])
        vl.updateFields()  # tell the vector layer to fetch changes from the provider

        for station in stations:
            stationid = re.sub("[^0-9]", "", station[0])
            station[-1] = station[-1].replace(',','') 
            #Creates a feature
            fet = QgsFeature()

            #Sets the geometry
            pt = QgsGeometry.fromWkt('Point('+str(station[2])+' '+str(station[1])+')')
            fet.setGeometry(pt)
            
            #Sets the attributes
            fet.setAttributes([int(stationid), station[0], float(station[-1]), "CA"])
            #Adds the feature
            pr.addFeatures([fet])

        # update layer's extent when new features have been added
        # because change of extent in provider is not propagated to the layer
        vl.updateExtents()
        QgsProject.instance().addMapLayer(vl)
        self.dlg.txt_cehqidlist.clear()
        self.dlg.btn_cehqlayer.setEnabled(False)
        self.dlg.txt_waterofficeidlist.clear()
        self.dlg.btn_waterofficelayer.setEnabled(False)
        self.stations=[]

    def downloadGISdata(self):
        outputdem = self.dlg.file_fetchdem.filePath()
        outputflowdir = self.dlg.file_fetchflowdir.filePath()
        outputlakes = self.dlg.file_fetchlakes.filePath()
        outputbankfull = self.dlg.file_fetchbankfull.filePath()
        outputsoil = self.dlg.file_fetchsoil.filePath()
        outputlanduse = self.dlg.file_fetchlanduse.filePath()
        file_is_chosen = False
        if outputdem:
            file_is_chosen = True
            gisScraper.dem(self,outputdem)
        if outputflowdir:  
            file_is_chosen = True
            gisScraper.flowdirection(self,outputflowdir)
        if outputlakes:
            file_is_chosen = True
            gisScraper.lakes(self,outputlakes)
        if outputbankfull:
            file_is_chosen = True
            gisScraper.bankfull(self,outputbankfull)
        if outputlanduse:
            file_is_chosen = True
            gisScraper.landuse(self,outputlanduse)
        if outputsoil:
            file_is_chosen = True
            gisScraper.soil(self,outputsoil)
        if file_is_chosen:
            self.dlg.lbl_progressbar.setText('Download complete.')
            self.dlg.progress_gisdownload.setValue(0) 
        else:
            self.dlg.lbl_progressbar.setText('Select files first!')


    def copypaths(self):
        outputdem = self.dlg.file_fetchdem.filePath()
        outputflowdir = self.dlg.file_fetchflowdir.filePath()
        outputlakes = self.dlg.file_fetchlakes.filePath()
        outputbankfull = self.dlg.file_fetchbankfull.filePath()
        outputsoil = self.dlg.file_fetchsoil.filePath()
        outputlanduse = self.dlg.file_fetchlanduse.filePath()

        if self.dlg.chk_samefilegis.isChecked():
            if outputdem:
                self.dlg.file_processdem.setFilePath(outputdem+'/na_con_3s.tif')
            if outputflowdir:
                self.dlg.file_processflowdir.setFilePath(outputflowdir+'/hyd_na_dir_15s.tif')
            if outputlakes:
                self.dlg.file_processlakes.setFilePath(outputlakes+'/HydroLAKES_polys_v10.shp')
            if outputbankfull:
                self.dlg.file_processbankfull.setFilePath(outputbankfull+'/nariv.shp')
            if outputsoil:
                self.dlg.file_processsoil.setFilePath(outputsoil+'/slc_v2r2_canada.shp')
            if outputlanduse:
                self.dlg.file_processlanduse.setFilePath(outputlanduse+'/landuse.tif')
        else:
            self.dlg.file_processdem.setFilePath('')
            self.dlg.file_processflowdir.setFilePath('')
            self.dlg.file_processlakes.setFilePath('')
            self.dlg.file_processbankfull.setFilePath('')
            self.dlg.file_processsoil.setFilePath('')
            self.dlg.file_processlanduse.setFilePath('')
    
    def processgisdata(self):
        overlay = self.dlg.file_giscliplayer.filePath()
        dem = self.dlg.file_processdem.filePath()
        flowdir = self.dlg.file_processflowdir.filePath()
        lakes = self.dlg.file_processlakes.filePath()
        bankfull = self.dlg.file_processbankfull.filePath()
        soil = self.dlg.file_processsoil.filePath()
        landuse = self.dlg.file_processlanduse.filePath()
        file_is_chosen = False

        if dem:
            file_is_chosen = True
            self.dlg.lbl_progressbar2.setText('Clipping DEM.')
            gisScraper.cliplayer(self, overlay, dem)
        if flowdir:
            file_is_chosen = True
            self.dlg.lbl_progressbar2.setText('Clipping flow direction.')
            gisScraper.cliplayer(self, overlay, flowdir)
        if lakes:
            file_is_chosen = True
            self.dlg.lbl_progressbar2.setText('Clipping lakes.')
            gisScraper.cliplayer(self, overlay, lakes)
        if bankfull:
            file_is_chosen = True
            self.dlg.lbl_progressbar2.setText('Clipping bankfull width.')
            gisScraper.cliplayer(self, overlay, bankfull)
        if soil:
            file_is_chosen = True
            self.dlg.lbl_progressbar2.setText('Clipping soil.')
            gisScraper.cliplayer(self, overlay, soil)
            self.dlg.lbl_progressbar2.setText('Joining soil attributes.')
            qrvn_soil = os.path.dirname(soil)+'/qrvn_soiltmp.shp'
            attTable = os.path.dirname(soil)+'/slc_v2r2_canada_cmp.dbf'
            gisScraper.joinattributes(self,qrvn_soil,attTable,'SL','SL','KINDMAT')
            #Need to rename attributes abreviation for basinmaker 
        if landuse:
            file_is_chosen = True
            self.dlg.lbl_progressbar2.setText('Clipping landuse.')
            gisScraper.cliplayer(self, overlay, landuse)
            self.dlg.lbl_progressbar2.setText('Polygonizing landuse raster.')
            qrvn_landuse = os.path.dirname(landuse)+'/tmp_landuse.tif'
            gisScraper.polygonize(self,qrvn_landuse)

        if file_is_chosen:
            self.dlg.lbl_progressbar2.setText('File processing complete.')
            self.dlg.progress_gisprocess.setValue(0) 
        else:
            self.dlg.lbl_progressbar2.setText('Select files first!')
        

    #This method opens the rvi file from the input directory and gets two values to populate them in the GUI
    def setModelname(self):
        inputdir = self.dlg.file_runinputdir.filePath() #Get the model input directory
        self.dlg.txt_runnameprefix.clear()
        self.dlg.txt_runrunname.clear()
        try:
            if inputdir:
                for file in os.listdir(inputdir):   #Lists all the files in the input folder
                    if file.endswith(".rvi"):       #Get the RVI file if it exists
                        self.dlg.txt_runnameprefix.setText(file.replace('.rvi','')) #Sets the file name prefix
                        rvifile = inputdir+separator+file
                        with open(rvifile,'r') as rvi:  #Read the RVI file
                            lines = rvi.readlines()
                            for line in lines:
                                if ':RunName' in line and '#:RunName' not in line:  #loops through the RVI file and searches for the :RunName keyword
                                    params = line.split()
                                    runname = params[params.index(':RunName')+1]    #Get the string after the :RunName keyword
                                    self.dlg.txt_runrunname.setText(runname)    #Set the RunName
        except Exception as e:
            self.iface.messageBar().pushInfo("Info", "Could not populate some information automatically.")
            self.iface.mainWindow().repaint()
            print(e)

    #This method runs a Raven model provided by the user.
    def runRaven(self):
        '''Runs a Raven model just like RavenViewLite3'''

        inputdir = self.dlg.file_runinputdir.filePath()  # Get the path where the model files are stored
        outputdir = self.dlg.file_runoutputdir.filePath()  # Get the path where to save the results of the simulation
        ravenExe = self.dlg.file_ravenexe.filePath()  # Get the path to the Raven.exe
        prefix = self.dlg.txt_runnameprefix.text()  # Get the chosen prefix
        runname = self.dlg.txt_runrunname.text()  # Get the runname (this can be empty)
        pathtomodel = inputdir + separator + prefix  # Get the complete path to the model

        pythonConsole = self.iface.mainWindow().findChild(QDockWidget, 'PythonConsole')
        if not pythonConsole or not pythonConsole.isVisible():  # If the python console is closed, open it
            self.iface.actionShowPythonDialog().trigger()  # It allows the user to see the Raven progress


        if self.dlg.combo_ravenexe_mode.currentText() == 'Executable':
            if self.dlg.file_ravenexe.filePath() == '':
                self.dlg.lbl_ravenexe_error.setText('Raven executable path not set! Go inside the settings menu, set the Raven executable path and try again.')
            else:
                self.dlg.lbl_ravenexe_error.setText('')
                self.iface.messageBar().pushInfo("Info",
                                                 "The Raven process has started, this could take a while to complete.")
                self.iface.mainWindow().repaint()
                try:
                    cmd = ravenExe, pathtomodel, "-o", outputdir, "-r", runname  # Command that launches the Raven model
                    self.docker.runCommand(cmd)
                except Exception as e:
                    print(e)
                    self.iface.messageBar().pushMessage("Error",
                                                        "An error occured while running Raven. Check the python console for more details.",
                                                        level=Qgis.Critical)
        elif self.dlg.combo_ravenexe_mode.currentText() == 'Flatpak':

                cmd = 'flatpak', 'run', 'ca.uwaterloo.Raven', pathtomodel, "-o", outputdir, "-r", runname  # Command that launches the Raven model
                rc = self.docker.runCommand(cmd)
                if rc != 0:
                    print("Couldn't run Raven as a Flatpak. Please check you have Flatpak and Raven installed.")
                    self.iface.messageBar().pushMessage("Error",
                                                        "An error occured while trying to run Raven. Verify Flatpak and Raven are installed.",
                                                        level=Qgis.Critical)
        else:
            print('Docker has not been implemented yet. Coming soon.')


    #This method is a port of the RavenR rvn_rvp_fill_template function
    #All credits go to Robert Chlumsky
    #https://github.com/rchlumsk/RavenR/blob/master/R/rvn_rvp_fill_template.R
    def fillRVPTemplate(self):
        inputdir = self.dlg.file_runinputdir.filePath() #Get the path where the model files are stored
        prefix = self.dlg.txt_runnameprefix.text()  #Get the chosen prefix
        rvifile = prefix+'.rvi'
        rvhfile = prefix+'.rvh'
        rvpfile = prefix+'.rvp'
        rvptemplatefile = inputdir + prefix +'.rvp_temp.rvp'
        script_dir = os.path.dirname(__file__) #<-- absolute dir the script is in
        ravenparametersfile ="ext_data/RavenParameters.dat"
        ravenparametersfile = os.path.join(script_dir, ravenparametersfile)
        soil_layers = getSoilLayers(inputdir,separator,rvifile)
        #!!Simplify the functions to only process the requested information!!
        try:
            landuseclasses,terrainclasses,vegclasses,soilprofileclasses = extractRVHhrus(inputdir,separator,rvhfile)
        except Exception as e:
            self.iface.messageBar().pushMessage("Error", "There is a problem with the .rvh file. Please check your .rvh file and the python console.",level=Qgis.Critical)
            print("Couldn't extract HRUs. This problem may be caused by a missing :HRUs block. It could also be that the attributes name of the :HRUs block"+
                  "do not match the number of attribute values."
                 )
        else:
            try:
                rvptemplate = readRVPtemplate(rvptemplatefile)
                #Read the RavenParameters.dat file and create a 2d list of its values
                rvn_paramsList = readRavenParams(ravenparametersfile)
            except Exception as e:
                self.iface.messageBar().pushMessage("Error", "There was an error while reading the .rvp file and the parameters file. Please check the python console.",level=Qgis.Critical)
                print(e)
            else:
                try:
                    with open(inputdir+separator+rvpfile, "w") as rvp:
                        #Write header
                        rvp.write("#".ljust(74, '=')+"#"
                                "\n# Generated by QRaven".ljust(76)+"#"+
                                "\n# Please report any issues on https://github.com/Scriptbash/QRaven/issues #\n"+
                                "#".ljust(74, '=')+"#\n\n")
                        #Write soil classes
                        rvp.write(("#".ljust(10, '-')+"SOIL CLASSES".ljust(21,'-')+"#\n\n"))
                        rvp.write(":SoilClasses\n"+
                                " ".ljust(3)+":Attributes,\n"+
                                " ".ljust(3)+":Units,\n")
                        for soil in range(soil_layers):
                            #rvp.write("SOIL_"+str((soil+1)).zfill(2))
                            rvp.write(" ".ljust(5)+"SOIL_"+str(soil+1)+",\n")
                        rvp.write(":EndSoilSoilClasses\n\n")
                        #Write land use classes
                        writeAttributes(':LandUseClasses',rvp,rvptemplate,rvn_paramsList,landuseclasses,soil_layers)
                        #Write vegetation classes
                        writeAttributes(':VegetationClasses',rvp,rvptemplate,rvn_paramsList,vegclasses,soil_layers)
                        #Write soil profiles
                        writeAttributes(':SoilProfiles',rvp,rvptemplate,rvn_paramsList,soilprofileclasses,soil_layers)
                        #Write global parameters
                        writeGlobalParameters(rvp,rvptemplate,rvn_paramsList)
                        #Write soil parameters
                        writeParametersList(':SoilParameterList',rvp,rvptemplate,rvn_paramsList,soil_layers)
                        #Write land use parameters
                        writeParametersList(':LandUseParameterList',rvp,rvptemplate,rvn_paramsList,landuseclasses)
                        #Write vegetation parameters
                        writeParametersList(':VegetationParameterList',rvp,rvptemplate,rvn_paramsList,vegclasses)
                    self.iface.messageBar().pushSuccess("Success", "RVP file written successfully")
                except Exception as e:
                    self.iface.messageBar().pushMessage("Error", "Could not write the .rvp file. Please check the python console.",level=Qgis.Critical)
                    print('An error occured when attempting to write the RVP file.')
                    print(e)

    #This method opens a new tab in the default web browser and points to the RavenView tool
    def openRavenView(self):
        url = 'http://raven.uwaterloo.ca/RavenView/RavenView.html'
        if computerOS !='macos':
            webbrowser.open(url, new = 2)
        else:
            cmd='/usr/bin/open '+ url
            os.system(cmd)

    #This method plots the resulting hydrograph
    def drawHydrographs(self):
        '''Plots the hydrograph from the ouput of a Raven model'''
        outputdir = self.dlg.file_runoutputdir.filePath()   #Get the path where the results of the simulation are stored
        runname = self.dlg.txt_runrunname.text()    #Get the runname (this can be empty
        if runname:
            filename = outputdir+separator+runname+'_Hydrographs.csv'    #Complete file name
        else: 
            filename = outputdir+separator+'Hydrographs.csv'
        #Pandas could have made this much easier, however the plugin must not depend on other python packages that would
        #require the user to install it manually. Therefore, the csv is read manually.
        try:
            with open(filename, "r") as file:
                csv_reader = csv.reader(file)
                headers = next(csv_reader)
                
                data = {}
                for title in headers:   #Loops through the column names
                    data[title] = []

                for row in csv_reader:
                    for i, title in enumerate(headers): 
                        data[title].append(row[i])   #Adds values inside the columns                   
    
            for i in range(len(data["date"])):
                data["date"][i] = datetime.datetime.strptime(data["date"][i], "%Y-%m-%d")   #Converts the date from string to datetime

            for i in range(len(data[headers[3]])):  #Using indexes here since the column name changes from models to models
                #Converts the precipitations from string to float. If it encounters a value it cannot convert such as "---" which
                #Raven sometimes adds, the value is set to 0
                try:
                    data[headers[3]][i] = float(data[headers[3]][i])
                except:
                    data[headers[3]][i] = 0
                    print("Warning : A value could not be converted from string to float. Overwritting with 0.")
            for i in range(len(data[headers[4]])):
                #Converts the flow from string to float
                try:
                    data[headers[4]][i] = float(data[headers[4]][i])
                except:
                    data[headers[4]][i] = 0
                    print("Warning : A value could not be converted from string to float. Overwritting with 0.")
            for i in range(len(data[headers[5]])):
                #Converts the observed flow from string to float
                try:
                    data[headers[5]][i] = float(data[headers[5]][i])
                except:
                    data[headers[5]][i] = 0
                    print("Warning : A value could not be converted from string to float. Overwritting with 0.")
            fig, ax = plt.subplots()
            ax.plot(data["date"], data[headers[3]], label=headers[3]) #Plots the precipitations by dates
            ax.plot(data["date"], data[headers[4]],label=headers[4])  #Plots the flow by dates
            ax.plot(data["date"], data[headers[5]],label=headers[5])    #Plots the observed flow by date
            ax.legend(loc="upper left") #Adds a legend
            ax.set_title("Hydrograph")  #Sets the title of the graph          
            fig.autofmt_xdate()
            fig.show()
        except Exception as e:
            print(e)
            self.iface.messageBar().pushMessage("Error", "An error occured while attempting to draw the hydrograph. Check the python console for more details.",level=Qgis.Critical)
    
    def checkUpdate(self):
        try:
            metadatafile = Path(__file__).parent / "metadata.txt"
            with open(metadatafile,'r') as metadata:  #Read the metadata file
                lines = metadata.readlines()
                for line in lines:
                    if 'version=' in line:  #loops through the metadata file and searches for the plugin version
                        pluginversion = line.split()
                        print(pluginversion[0])
                        installedversion =""
                        for letters in pluginversion[0]:
                            installedversion +=letters+' '
                        installedversion=[int(s) for s in installedversion.split() if s.isdigit()]
            print("Looking for updates")
            link = "https://raw.githubusercontent.com/Scriptbash/QRaven/main/qraven/metadata.txt"
            page = requests.get(link)
            content = page.text     
            keywords = content.splitlines()
            for word in keywords:
                if 'version=' in word:
                    latestrelease = word.split()
                    latestversion =""
                    for letters in latestrelease[0]:
                        latestversion +=letters+' '
                    latestversion=[int(s) for s in latestversion.split() if s.isdigit()]
            instver = ''
            relver = ''
            for number in installedversion:
                instver += str(number)
            for number in latestversion:
                relver += str(number)
            installedversion = int(instver)
            latestversion = int(relver)
            if installedversion == latestversion:
                print('QRaven is up to date')
                self.dlg.lbl_update.setText('QRaven is up to date.')
            elif installedversion > latestversion:
                print('Running a pre-release version')
                self.dlg.lbl_update.setText('Pre-release version. Please report any issues on GitHub.')
            elif installedversion < latestversion:
                self.iface.messageBar().pushInfo("Info", "A new version of QRaven is available.")
                print("Found an update. Please install the latest version of the plugin here: https://github.com/Scriptbash/QRaven/releases")
                self.dlg.lbl_update.setText('An update is available, please install the latest version <a href="https://github.com/Scriptbash/QRaven/releases">https://github.com/Scriptbash/QRaven/releases</a>')
        except Exception as e:
            print(e)
            print("Could not check for an update. Verify your internet connection.")
    
    #This method loads the models parameters into the GUI
    def loadModels(self):
        widget = self.dlg.sender()  #Get the widget name
        
        #Calls the function linked to the proper model to load
        if widget.objectName() == 'btn_reset': 
            resetmode = self.dlg.combo_resetmode.currentText()
            if resetmode == 'Full':
                fullReset(self)
            elif resetmode == 'Partial':
                partialReset(self)
        elif widget.objectName() == 'btn_load_hmets':
            partialReset(self)
            loadHmets(self)
        elif widget.objectName() == 'btn_load_hbvec':
            partialReset(self)
            loadHbvec(self)
        elif widget.objectName() == 'btn_load_hbvlight':
            partialReset(self)
            loadHbvlight(self)
        elif widget.objectName() == 'btn_load_ubcwm':
            partialReset(self)
            loadUbcwm(self)
        elif widget.objectName() == 'btn_load_gr4j':
            partialReset(self)
            loadGr4j(self)
        elif widget.objectName() == 'btn_load_canadianshield':
            partialReset(self)
            loadCanshield(self)
        elif widget.objectName() == 'btn_load_mohyse':
            partialReset(self)
            loadMohyse(self)
        elif widget.objectName() == 'btn_load_hypr':
            partialReset(self)
            loadHypr(self)
        elif widget.objectName() == 'btn_load_hymod':
            partialReset(self)
            loadHymod(self) 
        elif widget.objectName() == 'btn_load_awbm':
            partialReset(self)
            loadAwbm(self)

    def setStreamflowComboboxes(self):
        script_dir = os.path.dirname(__file__) #<-- absolute dir the script is in
        citiespath = "ext_data/cities.txt"
        regionspath = "ext_data/regions.txt"
        riverspath = "ext_data/rivers.txt"
        citiesfile = os.path.join(script_dir, citiespath)
        regionsfile = os.path.join(script_dir, regionspath)
        riversfile = os.path.join(script_dir, riverspath)

        cities = []
        with open(citiesfile) as file:
            for line in file:
                city = line.strip()
                if city:
                    cities.append(city)
        self.dlg.combo_cehqmunicipality.addItem("")
        self.dlg.combo_cehqmunicipality.addItems(cities)

        regions = []
        with open(regionsfile) as file:
            for line in file:
                region = line.strip()
                if region:
                    regions.append(region)
        self.dlg.combo_cehqadminregion.addItem("")            
        self.dlg.combo_cehqadminregion.addItems(regions)

        rivers = []
        with open(riversfile) as file:
            for line in file:
                river = line.strip('\n')
                if river:
                    rivers.append(river)
        self.dlg.combo_cehqriver.addItem("")            
        self.dlg.combo_cehqriver.addItems(rivers)

        provinces = ['All Provinces','Alberta','British Columbia','Manitoba',
                     'New Brunswick','Newfoundland and Labrador', 'Northwest Territories',
                     'Nova Scotia','Nunavut','Ontario','Prince Edward Island',
                      'Quebec','Saskatchewan','Yukon'
                    ]
        self.dlg.combo_watersurveyprovince.addItems(provinces)

    def setOstrichComboboxes(self):
        programtype = ['GeneticAlgorithm','BinaryGeneticAlgorithm','ShuffledComplexEvolution',
                       'BisectionAlgorithm','SamplingAlgorithm','ParticleSwarm','APPSO','PSO-GML',
                       'SimulatedAnnealing','DiscreteSimulatedAnnealing','VanderbiltSimulatedAnnealing',
                       'Levenberg-Marquardt','GML-MS','Powell','Steepest-Descent','Fletcher-Reeves ',
                       'RegressionStatistics','Jacobian','Hessian','Gradient','ModelEvaluation',
                       'GridAlgorithm','DDS','DDSAU','ParallelDDS','DiscreteDDS','GLUE','RejectionSampler',
                       'MetropolisSampler','SMOOTH','PADDS','ParaPADDS','BEERS'
                      ]
        telescopingStrategy = ['none','convex_power','convex','linear','concave','delayed-concave']
        programtype.sort()
        telescopingStrategy.sort()
        self.dlg.combo_programtype.addItems(programtype)
        self.dlg.combo_programtype.setCurrentText('Levenberg-Marquardt')
        self.dlg.combo_telescopingstrat.addItems(telescopingStrategy)
        self.dlg.combo_telescopingstrat.setCurrentText('none')
 
    def storesettings(self):
        containerization = self.dlg.combo_container.currentText()
        registry = self.dlg.combo_registry.currentText()
        containerimage = self.dlg.combo_dockerimage.currentText()
        raven_mode = self.dlg.combo_ravenexe_mode.currentText()
        ostrich_mode = self.dlg.combo_ostrichexe_mode.currentText()
        raven_exe_path = self.dlg.file_ravenexe.filePath()
        ostrich_exe_path = self.dlg.file_ostrichexe.filePath()
        username = self.dlg.txt_casparusername.text()
        password = self.dlg.txt_casparpassword.text()
        resetmode = self.dlg.combo_resetmode.currentText()
        menubar = self.dlg.combo_menubar.currentText()
        
        if containerization != self.containerization or registry != self.registry or containerimage != self.containerimage:
            self.dlg.lbl_restartrequired.setText('QGIS restart required to apply the changes.')


        s = QgsSettings()
        
        s.setValue("qraven/container", containerization)
        s.setValue("qraven/registry", registry)
        s.setValue("qraven/image", containerimage)
        s.setValue("qraven/raven_mode", raven_mode)
        s.setValue("qraven/ostrich_mode", ostrich_mode)
        s.setValue("qraven/raven_exe", raven_exe_path)
        s.setValue("qraven/ostrich_exe", ostrich_exe_path)
        s.setValue("qraven/casparUsername", username)
        s.setValue("qraven/casparPassword", password)
        s.setValue("qraven/resetmode", resetmode)
        s.setValue("qraven/menubar", menubar)

        self.iface.messageBar().pushSuccess("Success", "Your settings have been saved.")

    def loadsettings(self):
        s = QgsSettings()

        self.containerization = s.value("qraven/container", "Docker")
        self.registry = s.value("qraven/registry", "ghcr.io")
        self.containerimage = s.value("qraven/image", "scriptbash/qraven:latest")

        raven_mode = s.value("qraven/raven_mode", "Executable")
        ostrich_mode = s.value("qraven/ostrich_mode", "Executable")
        raven_exe_path = s.value("qraven/raven_exe", "")
        ostrich_exe_path = s.value("qraven/ostrich_exe", "")

        username = s.value("qraven/casparUsername", "")
        password = s.value("qraven/casparPassword", "")
        resetmode = s.value("qraven/resetmode", "Full")
        menubar = s.value("qraven/menubar", "Default")

        if computerOS != 'linux':
            self.dlg.combo_ravenexe_mode.model().item(1).setEnabled(False)
        else:
            self.dlg.combo_ravenexe_mode.model().item(1).setEnabled(True)

        if raven_mode != 'Executable':
            self.dlg.file_ravenexe.setEnabled(False)
        else:
            self.dlg.file_ravenexe.setEnabled(True)
        if ostrich_mode != 'Executable':
            self.dlg.file_ostrichexe.setEnabled(False)
        else:
            self.dlg.file_ostrichexe.setEnabled(True)

        self.dlg.combo_container.setCurrentText(self.containerization)
        self.dlg.combo_registry.setCurrentText(self.registry)
        self.dlg.combo_dockerimage.setCurrentText(self.containerimage)
        self.dlg.combo_ravenexe_mode.setCurrentText(raven_mode)
        self.dlg.combo_ostrichexe_mode.setCurrentText(ostrich_mode)
        self.dlg.file_ravenexe.setFilePath(raven_exe_path)
        self.dlg.file_ostrichexe.setFilePath(ostrich_exe_path)
        self.dlg.txt_casparusername.setText(username)
        self.dlg.txt_casparpassword.setText(password)
        self.dlg.combo_resetmode.setCurrentText(resetmode)
        self.dlg.combo_menubar.setCurrentText(menubar)
    
    def show_RavenView(self):
        self.w = RavenviewWindow()
        self.w.show()

class RavenviewWindow(QWebView):
    """
    This "window" is a QWidget. If it has no parent, it
    will appear as a free-floating window as we want.
    """
    def __init__(self):
        #super().__init__()
        QWebView.__init__(self)
        self.settings().setAttribute(QWebSettings.LocalContentCanAccessRemoteUrls, True)
        self.settings().setAttribute(QWebSettings.JavascriptEnabled, True)
        self.settings().setAttribute(QWebSettings.DeveloperExtrasEnabled, True)
        self.current_url = ''
        self.load(QUrl("http://raven.uwaterloo.ca/RavenView/RavenView.html"))
        self.loadFinished.connect(self._on_load_finished)
        self.urlChanged.connect(self._on_url_change)

    def _on_load_finished(self):
        self.current_url = self.url().toString()
    
    def _on_url_change(self):
        self.page().mainFrame().evaluateJavaScript("alert('This is a test')")

    


#This function returns the user's operating system. Mainly used to put slashes and backslashes accordingly in paths            
def checkOS():
    '''Makes a simple check to verify which operating system the user is using.

        Returns a slash or backslash as a string depending on the OS.
    '''
    if platform == "linux" or platform == "linux2":
        return "linux","/"
    elif platform == "darwin":
        return "macos", "/"

    elif platform == "win32":
        return "windows", "\\"

computerOS, separator = checkOS()