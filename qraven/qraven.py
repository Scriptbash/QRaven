# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QRaven

 A QGIS plugin to help generate input files for Raven
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-03-22
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Francis Lapointe
        email                : francis.lapointe5@usherbrooke.ca
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from pathlib import Path
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import *
#from PyQt5 import QFileDialog
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .qraven_dialog import QRavenDialog

from qgis.core import Qgis, QgsVectorLayer, QgsRasterLayer, QgsProject
import os.path
from sys import platform
import subprocess
from subprocess import Popen, PIPE
import matplotlib.pyplot as plt
import csv, datetime, webbrowser, ntpath
from urllib.request import urlopen
import requests

# try:
#     import netCDF4 as nc
#     netcdf_installed = True
# except Exception as e:
#     netcdf_installed = False
#     print(e)


class QRaven:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'QRaven_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&QRaven')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('QRaven', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/qraven/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Generate Raven input files'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&QRaven'),
                action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = QRavenDialog()

            self.checkUpdate()

            #-------------Raven RVI-------------#
            #If the checkbox is checked/unchecked, enables/disables the associated widget
            self.dlg.chk_duration.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_runname.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_outputdir.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_outputinterval.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_wateryear.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_outputdump.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_rvhfilename.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_rvcfilename.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_rvpfilename.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_rvtfilename.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_reservoirdemandalloc.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_chunksize.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_readlivefile.stateChanged.connect(self.toggleWidget)
            self.dlg.chk_disablehru.stateChanged.connect(self.toggleWidget)
            self.dlg.combo_stat1.activated.connect(self.toggleWidget)
            self.dlg.combo_stat2.activated.connect(self.toggleWidget)
            self.dlg.combo_stat3.activated.connect(self.toggleWidget)
            self.dlg.combo_stat4.activated.connect(self.toggleWidget)
            self.dlg.combo_stat5.activated.connect(self.toggleWidget)
            self.dlg.combo_stat6.activated.connect(self.toggleWidget)
            self.dlg.combo_stat7.activated.connect(self.toggleWidget)
            #Calls the function to enable/disable the spinbox for the soilmodel and the interpolation lineedit
            self.dlg.combo_soilmod.activated.connect(self.toggleSoilModel)
            self.dlg.combo_interpo.activated.connect(self.toggleInterpolation)

            #Calls the function to browse the computer for an output folder
            self.dlg.btn_outputdir.clicked.connect(self.browseDirectory)
        
            procname =['','Precipitation','CanopyEvap','SoilEvaporation','LakeEvaporation',
                        'OpenWaterEvaporation','Infiltration','Percolation','CapillaryRise',
                        'Baseflow','Interflow','Seepage','DepressionOverflow','LakeRelease',
                        'Abstraction','SnowMelt','Snow Refreeze','Snow Balance','Sublimation',
                        'SnowAlbedoEvolve','CanopyDrip','CropHeatUnitEvolve','GlacierMelt',
                        'GlacierRelease','Flush','Overflow','Split','Convolution','LateralFlush'
                      ]
            self.dlg.btn_addhydroproc.clicked.connect(self.addTableRow)
            self.dlg.btn_rmhydroproc.clicked.connect(self.removeTableRow)
            self.dlg.btn_addtransport.clicked.connect(self.addTransportProc)
            self.dlg.btn_rmtransport.clicked.connect(self.rmTransportProc)
            

            #Calls the function to write the RVI file
            self.dlg.btn_write.clicked.connect(self.writeRVI)
            #----------------------------------------#

            #-------------BasinMaker RVH-------------#
            #Calls the function that toggles the proper widgets depending on the mode chosen
            self.dlg.buttonGroup.buttonToggled.connect(self.toggleWidget)   #Define project spatial extent
            self.dlg.buttonGroup_2.buttonToggled.connect(self.toggleWidget)  #Delineate routing structure without lakes
            self.dlg.file_lakes.fileChanged.connect(self.toggleWidget)  #Add lake and obs control points
            self.dlg.file_lakes.fileChanged.connect(self.loadAttributes)
            self.dlg.file_pointsinterest.fileChanged.connect(self.loadAttributes)
            self.dlg.chk_epsgcode.stateChanged.connect(self.toggleWidget)   #Enables/disables the EPSG
            self.dlg.file_bankfullwidth.fileChanged.connect(self.toggleWidget)  #Add lake and obs control points
            self.dlg.file_bankfullwidth.fileChanged.connect(self.loadAttributes)
            self.dlg.file_landuserast.fileChanged.connect(self.toggleWidget)  #Add lake and obs control points

            #Calls the function to run the docker container
            self.dlg.btn_dockerrun.clicked.connect(self.dockerinit)
            #Calls the function to remove the docker container
            self.dlg.btn_dockerrm.clicked.connect(self.dockerdelete)
            #----------------------------------------#

            #----------Generate GridWeights---------#
            self.dlg.file_netcdf.fileChanged.connect(self.toggleWidget)
            self.dlg.btn_rungridweight.clicked.connect(self.generateGridWeights)
            self.dlg.btn_rmigridweight.clicked.connect(self.dockerdelete)
            #----------------------------------------#


            #-------------Run Raven Model-------------#
            self.dlg.file_runinputdir.fileChanged.connect(self.setModelname)
            self.dlg.btn_runraven.clicked.connect(self.runRaven)
            self.dlg.btn_gatheroutput.clicked.connect(self.drawHydrographs)
            self.dlg.btn_ravenview.clicked.connect(self.openRavenView)
            #----------------------------------------#

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()


        # See if OK was pressed
        if result:
            # May remove completely this and keep only a close button in the GUI
            print('This button does not do anything. Use the other buttons instead.' )
    

    #This method enables and disables widgets based on their checkboxes/radiobutton state
    def toggleWidget(self):
        '''Enables/disables widgets based on the widget calling the method'''

        widget = self.dlg.sender()  #Get the widget name
        
        #Conditions for the Raven RVI section below
        if widget.objectName() == 'chk_duration':           #Enables/disables the duration and enddate widgets
            if self.dlg.chk_duration.isChecked():
                self.dlg.date_enddate.setEnabled(False)
                self.dlg.spin_duration.setEnabled(True)
            else:
                self.dlg.date_enddate.setEnabled(True)
                self.dlg.spin_duration.setEnabled(False) 
        elif widget.objectName() == 'chk_runname':          #Enables/disables the runname line edit
            if self.dlg.chk_runname.isChecked():
                self.dlg.txt_runname.setEnabled(True)
            else:
                self.dlg.txt_runname.setEnabled(False)
        elif widget.objectName() == 'chk_outputdir':        #Enables/disables the outputdirectory qgsfileedit
            if self.dlg.chk_outputdir.isChecked():
                self.dlg.file_outputdir.setEnabled(True)
            else:
                self.dlg.file_outputdir.setEnabled(False)        
        elif widget.objectName() == 'chk_outputinterval':   #Enables/disables the outputinterval spinbox
            if self.dlg.chk_outputinterval.isChecked():
                self.dlg.spin_outinterval.setEnabled(True)
            else:
                self.dlg.spin_outinterval.setEnabled(False) 
        elif widget.objectName() == 'chk_wateryear':        #Enables/disables the wateryear spinbox
            if self.dlg.chk_wateryear.isChecked():
                self.dlg.spin_wateryear.setEnabled(True)
            else:
                self.dlg.spin_wateryear.setEnabled(False) 
        elif widget.objectName() == 'chk_outputdump':
            if self.dlg.chk_outputdump.isChecked():
                self.dlg.date_outputdump.setEnabled(True)
            else:
                self.dlg.date_outputdump.setEnabled(False) 
        elif widget.objectName() == 'chk_rvhfilename':
            if self.dlg.chk_rvhfilename.isChecked():
                self.dlg.txt_rvhfilename.setEnabled(True)
            else:
                self.dlg.txt_rvhfilename.setEnabled(False) 
        elif widget.objectName() == 'chk_rvcfilename':
            if self.dlg.chk_rvcfilename.isChecked():
                self.dlg.txt_rvcfilename.setEnabled(True)
            else:
                self.dlg.txt_rvcfilename.setEnabled(False) 
        elif widget.objectName() == 'chk_rvpfilename':
            if self.dlg.chk_rvpfilename.isChecked():
                self.dlg.txt_rvpfilename.setEnabled(True)
            else:
                self.dlg.txt_rvpfilename.setEnabled(False) 
        elif widget.objectName() == 'chk_rvtfilename':
            if self.dlg.chk_rvtfilename.isChecked():
                self.dlg.txt_rvtfilename.setEnabled(True)
            else:
                self.dlg.txt_rvtfilename.setEnabled(False) 
        elif widget.objectName() == 'chk_reservoirdemandalloc':
            if self.dlg.chk_reservoirdemandalloc.isChecked():
                self.dlg.combo_reservoirdemandalloc.setEnabled(True)
            else:
                self.dlg.combo_reservoirdemandalloc.setEnabled(False) 
        elif widget.objectName() == 'chk_chunksize':
            if self.dlg.chk_chunksize.isChecked():
                self.dlg.spin_chunksize.setEnabled(True)
            else:
                self.dlg.spin_chunksize.setEnabled(False) 
        elif widget.objectName() == 'chk_readlivefile':
            if self.dlg.chk_readlivefile.isChecked():
                self.dlg.spin_readlivefile.setEnabled(True)
            else:
                self.dlg.spin_readlivefile.setEnabled(False) 
        elif widget.objectName() == 'chk_disablehru':   #Enables/disables the disable hrus text edit
            if self.dlg.chk_disablehru.isChecked():
                self.dlg.txt_disablehru.setEnabled(True)
            else:
                self.dlg.txt_disablehru.setEnabled(False)
        elif widget.objectName() == "combo_stat1":
            if self.dlg.combo_stat1.currentText().lower() == "histogram":
                self.dlg.spin_min1.setEnabled(True)
                self.dlg.spin_max1.setEnabled(True)
                self.dlg.spin_bin1.setEnabled(True)
            else:
                self.dlg.spin_min1.setEnabled(False)
                self.dlg.spin_max1.setEnabled(False)
                self.dlg.spin_bin1.setEnabled(False)
        elif widget.objectName() == "combo_stat2":
            if self.dlg.combo_stat2.currentText().lower() == "histogram":
                self.dlg.spin_min2.setEnabled(True)
                self.dlg.spin_max2.setEnabled(True)
                self.dlg.spin_bin2.setEnabled(True)
            else:
                self.dlg.spin_min2.setEnabled(False)
                self.dlg.spin_max2.setEnabled(False)
                self.dlg.spin_bin2.setEnabled(False)
        elif widget.objectName() == "combo_stat3":
            if self.dlg.combo_stat3.currentText().lower() == "histogram":
                self.dlg.spin_min3.setEnabled(True)
                self.dlg.spin_max3.setEnabled(True)
                self.dlg.spin_bin3.setEnabled(True)
            else:
                self.dlg.spin_min3.setEnabled(False)
                self.dlg.spin_max3.setEnabled(False)
                self.dlg.spin_bin3.setEnabled(False)
        elif widget.objectName() == "combo_stat4":
            if self.dlg.combo_stat4.currentText().lower() == "histogram":
                self.dlg.spin_min4.setEnabled(True)
                self.dlg.spin_max4.setEnabled(True)
                self.dlg.spin_bin4.setEnabled(True)
            else:
                self.dlg.spin_min4.setEnabled(False)
                self.dlg.spin_max4.setEnabled(False)
                self.dlg.spin_bin4.setEnabled(False)
        elif widget.objectName() == "combo_stat5":
            if self.dlg.combo_stat5.currentText().lower() == "histogram":
                self.dlg.spin_min5.setEnabled(True)
                self.dlg.spin_max5.setEnabled(True)
                self.dlg.spin_bin5.setEnabled(True)
            else:
                self.dlg.spin_min5.setEnabled(False)
                self.dlg.spin_max5.setEnabled(False)
                self.dlg.spin_bin5.setEnabled(False)
        elif widget.objectName() == "combo_stat6":
            if self.dlg.combo_stat6.currentText().lower() == "histogram":
                self.dlg.spin_min6.setEnabled(True)
                self.dlg.spin_max6.setEnabled(True)
                self.dlg.spin_bin6.setEnabled(True)
            else:
                self.dlg.spin_min6.setEnabled(False)
                self.dlg.spin_max6.setEnabled(False)
                self.dlg.spin_bin6.setEnabled(False)
        elif widget.objectName() == "combo_stat7":
            if self.dlg.combo_stat7.currentText().lower() == "histogram":
                self.dlg.spin_min7.setEnabled(True)
                self.dlg.spin_max7.setEnabled(True)
                self.dlg.spin_bin7.setEnabled(True)
            else:
                self.dlg.spin_min7.setEnabled(False)
                self.dlg.spin_max7.setEnabled(False)
                self.dlg.spin_bin7.setEnabled(False)
        #Conditions for the BasinMaker RVH section below
        elif widget.objectName() == 'buttonGroup':  #buttonGroup is the group of radiobuttons for the mode of define project spatial extent
            if self.dlg.rb_modehybasin.isChecked(): #If the selected mode is using_hybasin
                self.dlg.file_hybasin.setEnabled(True)
                self.dlg.txt_hybasin.setEnabled(True)
                self.dlg.txt_outletlat.setEnabled(False)
                self.dlg.txt_outletlon.setEnabled(False)
                self.dlg.file_providedply.setEnabled(False)
                self.dlg.spin_buffer.setEnabled(True)
            elif self.dlg.rb_outletpt.isChecked():  #Mode is using_outlet_pt
                self.dlg.file_hybasin.setEnabled(False)
                self.dlg.txt_hybasin.setEnabled(False)
                self.dlg.txt_outletlat.setEnabled(True)
                self.dlg.txt_outletlon.setEnabled(True)
                self.dlg.file_providedply.setEnabled(False)
                self.dlg.spin_buffer.setEnabled(False)
            elif self.dlg.rb_providedply.isChecked():   #Mode is using_provided_ply
                self.dlg.file_hybasin.setEnabled(False)
                self.dlg.txt_hybasin.setEnabled(False)
                self.dlg.txt_outletlat.setEnabled(False)
                self.dlg.txt_outletlon.setEnabled(False)
                self.dlg.file_providedply.setEnabled(True)
                self.dlg.spin_buffer.setEnabled(True)
            else:
                self.dlg.file_hybasin.setEnabled(False) #Mode is using_dem
                self.dlg.txt_hybasin.setEnabled(False)
                self.dlg.txt_outletlat.setEnabled(False)
                self.dlg.txt_outletlon.setEnabled(False)
                self.dlg.file_providedply.setEnabled(False)
                self.dlg.spin_buffer.setEnabled(False)
        elif widget.objectName() == 'buttonGroup_2':  #buttonGroup_2 is the group of radiobuttons for the mode of delineate routing structure w/o lakes
            if self.dlg.rb_fdr.isChecked(): #mode is using_fdr
                self.dlg.file_fdr.setEnabled(True)
            else:
                self.dlg.file_fdr.setEnabled(False) #Mode is using_dem
        elif widget.objectName() == 'file_lakes':   #Add lake and obs control point
            if self.dlg.file_lakes.filePath() != '':   #If there is a lake layer provided, enable the fields 
                self.dlg.combo_lakeid.setEnabled(True)
                self.dlg.combo_laketype.setEnabled(True)
                self.dlg.combo_lakevol.setEnabled(True)
                self.dlg.combo_lakeavgdepth.setEnabled(True)
                self.dlg.combo_lakearea.setEnabled(True)
                self.dlg.spin_conlakearea.setEnabled(True)
                self.dlg.spin_nonconlakearea.setEnabled(True)
            else:   #If the layer is removed or there's no layer, disable the fields
                self.dlg.combo_lakeid.setEnabled(False)
                self.dlg.combo_laketype.setEnabled(False)
                self.dlg.combo_lakevol.setEnabled(False)
                self.dlg.combo_lakeavgdepth.setEnabled(False)
                self.dlg.combo_lakearea.setEnabled(False)
                self.dlg.spin_conlakearea.setEnabled(False)
                self.dlg.spin_nonconlakearea.setEnabled(False)
        elif widget.objectName() == 'chk_epsgcode':  
            if self.dlg.chk_epsgcode.isChecked():   #If the EPSG checkbox is checked, enable the EPSG line edit
                self.dlg.txt_epsgcode.setEnabled(True)
            else:
                self.dlg.txt_epsgcode.setEnabled(False)
        elif widget.objectName() == 'file_bankfullwidth':   #Add hydrology related attributes
            if self.dlg.file_bankfullwidth.filePath() != '':    #If there is a layer for bankfull width, enable the required fields
                self.dlg.combo_bankfullwidth.setEnabled(True)
                self.dlg.combo_bankfulldepth.setEnabled(True)
                self.dlg.combo_bankfulldischarge.setEnabled(True)
                self.dlg.combo_bankfulldrainarea.setEnabled(True)
                self.dlg.spin_kcoef.setEnabled(False)
                self.dlg.spin_ccoef.setEnabled(False)

            else:   #If the layer is removed or there's no layer, disable the fields
                self.dlg.combo_bankfullwidth.setEnabled(False)
                self.dlg.combo_bankfulldepth.setEnabled(False)
                self.dlg.combo_bankfulldischarge.setEnabled(False)
                self.dlg.combo_bankfulldrainarea.setEnabled(False)
                self.dlg.spin_kcoef.setEnabled(True)
                self.dlg.spin_ccoef.setEnabled(True)

        elif widget.objectName() == 'file_landuserast':   #Add hydrology related attributes
            if self.dlg.file_landuserast.filePath() != '':    #If there is a layer for landuse (raster), enable the required fields
                self.dlg.file_landusemanning.setEnabled(True)
            else:   #If the layer is removed or there's no layer, disable the fields
                self.dlg.file_landusemanning.setEnabled(False) 

        elif widget.objectName() == 'file_netcdf':
            if os.path.splitext(self.dlg.file_netcdf.filePath())[1] == '.shp':
                self.dlg.combo_ncattributes.setEnabled(True)
                self.dlg.txt_dimlon.setEnabled(False)
                self.dlg.txt_dimlat.setEnabled(False)
                self.dlg.txt_varlon.setEnabled(False)
                self.dlg.txt_varlat.setEnabled(False)
                self.loadAttributes()
            else:
                self.dlg.combo_ncattributes.setEnabled(False)
                self.dlg.txt_dimlon.setEnabled(True)
                self.dlg.txt_dimlat.setEnabled(True)
                self.dlg.txt_varlon.setEnabled(True)
                self.dlg.txt_varlat.setEnabled(True)
             

    #This method enables and disables the spinbox next to the SoilModel combobox depending on the selected value of the combobox
    def toggleSoilModel(self):
        '''Toggles the spinbox for the number of soils if the soil model value is soil_multilayer'''
        if self.dlg.combo_soilmod.currentText().lower() == "soil_multilayer":
            self.dlg.spin_soilmod.setEnabled(True)
        else:
            self.dlg.spin_soilmod.setEnabled(False)


    #This method enables and disables the line edit next to the InterpolationMethod if the value is INTERP_FROM_FILE.
    def toggleInterpolation(self):
        '''Toggles the lineEdit for the interpolation file if the interpolationMethod value is inter_from_file'''
        if self.dlg.combo_interpo.currentText().lower() == "interp_from_file":
            self.dlg.txt_interpofile.setEnabled(True)
        else:
            self.dlg.txt_interpofile.setEnabled(False)


    #This method opens a file explorer to select an output folder
    def browseDirectory(self):
        '''Allows to browse the computer for a directory'''
        dir = str(QFileDialog.getExistingDirectory(None, "Select Directory"))
        self.dlg.txt_outputdir.setText(dir)
    

    def addTableRow(self,procname):
        #List that contains every process name
        procname =['','Precipitation','CanopyEvap','SoilEvaporation','LakeEvaporation',
                        'OpenWaterEvaporation','Infiltration','Percolation','CapillaryRise',
                        'Baseflow','Interflow','Seepage','DepressionOverflow','LakeRelease',
                        'Abstraction','SnowMelt','Snow Refreeze','Snow Balance','Sublimation',
                        'SnowAlbedoEvolve','CanopyDrip','CropHeatUnitEvolve','GlacierMelt',
                        'GlacierRelease','Flush','Overflow','Split','Convolution','LateralFlush'
            ]
        table = self.dlg.table_hydroprocess #Get the hydrologic processes table
        currentRow = table.rowCount()   #Get the number of rows the table has
        table.insertRow(currentRow) #Inserts a new row below the last row
        combo_proc = QComboBox() 
        combo_alg = QComboBox()
        combo_from = QComboBox()   
        combo_to = QComboBox()
        chk_isconditional = QCheckBox()
        combo_basedtype = QComboBox()
        combo_comparison = QComboBox()
        txt_hrutype = QLineEdit()
        combo_proc.addItems(procname)   #Add a combobox in the new row with all the available processes
        combo_basedtype.setEnabled(False)
        combo_comparison.setEnabled(False)
        txt_hrutype.setEnabled(False)
        table.setCellWidget(currentRow, 0, combo_proc)  #Sets the new combobox in the first column and in the new row
        table.setCellWidget(currentRow, 1, combo_alg)
        table.setCellWidget(currentRow, 2, combo_from)
        table.setCellWidget(currentRow, 3, combo_to)
        table.setCellWidget(currentRow, 4, chk_isconditional)
        table.setCellWidget(currentRow, 5, combo_basedtype)
        table.setCellWidget(currentRow, 6, combo_comparison)
        table.setCellWidget(currentRow, 7, txt_hrutype)

        table.resizeColumnsToContents() #Resizes the width of the column automatically
        combo_proc.currentTextChanged.connect(self.setProcAlg)  #Updates the algorithm combobox if the process changes
        chk_isconditional.stateChanged.connect(self.enableConditionalProc)

    def removeTableRow(self):
        table = self.dlg.table_hydroprocess
        selectedRow = table.currentRow()
        table.removeRow(selectedRow)


    def setProcAlg(self):
       
        combo_alg = QComboBox()
        currentWidget = self.dlg.sender()
        index = self.dlg.table_hydroprocess.indexAt(currentWidget.pos())
        widgetRow = index.row()
        #print(index.row())
        combo_alg.clear()
        combo_alg.addItem('')
        if isinstance(currentWidget, QComboBox):
            selectedProc = currentWidget.currentText()
            #print(selectedProc)
            if selectedProc == 'Precipitation':
                combo_alg.addItems(precipalg)
            elif selectedProc == 'CanopyEvap':
                combo_alg.addItems(canopevapAlg)
            elif selectedProc == 'SoilEvaporation':
                combo_alg.addItems(soilevapAlg)
            elif selectedProc == 'LakeEvaporation':
                combo_alg.addItems(lakeevapAlg)
            elif selectedProc == 'OpenWaterEvaporation':
                combo_alg.addItems(openwaterevapAlg)
            elif selectedProc == 'Infiltration':
                combo_alg.addItems(infiltrationAlg)
            elif selectedProc == 'Percolation':
                combo_alg.addItems(percolationAlg)
            elif selectedProc == 'CapillaryRise':
                combo_alg.addItems(cappilaryriseAlg)
            elif selectedProc == 'Baseflow':
                combo_alg.addItems(baseflowAlg)
            elif selectedProc == 'Interflow':
                combo_alg.addItems(interflowAlg)
            elif selectedProc == 'Seepage':
                combo_alg.addItems(seepageAlg)
            elif selectedProc == 'DepressionOverflow':
                combo_alg.addItems(depresoverflowAlg)
            elif selectedProc == 'LakeRelease':
                combo_alg.addItems(lakereleaseAlg)
            elif selectedProc == 'Abstraction':
                combo_alg.addItems(abstractionAlg)
            elif selectedProc == 'SnowMelt':
                combo_alg.addItems(snowmeltAlg)
            elif selectedProc == 'Snow Refreeze':
                combo_alg.addItems(snowrefreezeAlg)
            elif selectedProc == 'Snow Balance':
                combo_alg.addItems(snowbalanceAlg)
            elif selectedProc == 'Sublimation':
                combo_alg.addItems(sublimationAlg)
            elif selectedProc == 'SnowAlbedoEvolve':
                combo_alg.addItems(snowalbedoevolveAlg)
            elif selectedProc == 'CanopyDrip':
                combo_alg.addItems(canopydripAlg)
            elif selectedProc == 'CropHeatUnitEvolve':
                combo_alg.addItems(cropheatunitevAlg)
            elif selectedProc == 'GlacierMelt':
                combo_alg.addItems(glaciermeltAlg)
            elif selectedProc == 'GlacierRelease':
                combo_alg.addItems(glacierreleaseAlg)
            elif selectedProc == 'Flush':
                combo_alg.addItems(flushAlg)
            elif selectedProc == 'Overflow':
                combo_alg.addItems(overflowAlg)
            elif selectedProc == 'Split':
                combo_alg.addItems(splitAlg)
            elif selectedProc == 'Convolution':
                combo_alg.addItems(convolutionAlg)
            elif selectedProc == 'LateralFlush':
                combo_alg.addItems(lateralflushAlg)
        self.dlg.table_hydroprocess.setCellWidget(widgetRow, 1, combo_alg)
        self.dlg.table_hydroprocess.resizeColumnsToContents()
        combo_alg.currentTextChanged.connect(self.setStorage)   #Updates the compartments combobox if the algorithm changed

    #This method sets the combobox values for the from and to compartments based on the selected algorithm
    def setStorage(self):

        #Lists of the compartments of each algorithm. Can easily add new compartments if new compartments are added in Raven
        fromPrecip = ["ATMOS_PRECIP"]
        toPrecip = ["MULTIPLE"]
        fromCanevp = ["CANOPY"]
        toCanevp = ["ATMOSPHERE"]
        fromSoilevap = ["SOIL[0]"]
        toSoilevap = ["ATMOSPHERE"]
        fromLakeevap = ["LAKE","SURFACE_WATER"]
        toLakeevap = ["ATMOSPHERE"]
        fromOpenwaterevap = ["DEPRESSION"]
        toOpenwaterevap = ["ATMOSPHERE"]
        fromInfiltration = ["PONDED_WATER"]
        toInfiltration = ["SOIL[0]", "SURFACE_WATER"]
        toInfiltUBC = ["SOIL[0]","SOIL[1]","SOIL[2]","SOIL[3]","SURFACE_WATER"]
        fromPercolation = []
        toPercolation = []
        fromCapillaryRise = []
        toCapillaryRise = []
        fromBaseflow = []
        toBaseflow = ['SURFACE_WATER']
        fromInterflow = []
        toInterflow = ['SURFACE_WATER']
        fromSeepage = ['DEPRESSION']
        toSeepage = []
        fromDepressOverflow = ['DEPRESSION']
        toDepressOverflow = ['SURFACE_WATER']
        fromLakeRelease = ['LAKE']
        toLakeRelease = ['SURFACE_WATER']
        fromAbstraction = ['PONDED_WATER']
        toAbstraction = ['DEPRESSION']
        fromSnowmelt = ['SNOW']
        toSnowmelt = ['SNOW_LIQ','PONDED_WATER','SURFACE_WATER']
        fromSnowrefreeze = ['SNOW_LIQ']
        toSnowrefreeze = ['SNOW']
        fromSnowbalSimple = ['SNOW']
        toSnowbalSimple = ['PONDED_WATER','SNOW_LIQ']
        fromSnowbalColdcontent = ['SNOW','SNOW_LIQ']
        toSnowbalColdcontent = ['SNOW','SNOW_LIQ','PONDED_WATER']
        fromSnowbalHBV = ['SNOW','SNOW_LIQ']
        toSnowbalHBV = ['SOIL[0]']
        fromSnowbaltwolayer = ['SNOW[0,1]','SNOW_LIQ[0,1]']
        toSnowbaltwolayer = ['SNOW[0,1]','SNOW_LIQ[0,1]','SURFACE_WATER']
        fromSnowbalCema = ['SNOW']
        toSnowbalCema = ['PONDED_WATER']
        fromSnowbalGawser = ['SNOW','SNOW_LIQ']
        toSnowbalGawser = ['SNOW_LIQ','ATMOSPHERE','PONDED_WATER']
        fromSnowbalUBC = ['SNOW','SNOW_LIQ']
        toSnowbalUBC = ['SNOW','SNOW_LIQ','SURFACE_WATER']
        fromSublimation = ['SNOW']
        toSublimation = ['ATMOSPHERE']
        fromCanopydrip = ['CANOPY']
        toCanopydrip = ['PONDED_WATER']
        fromGlaciermelt = ['GLACIER_ICE']
        toGlaciermelt = ['GLACIER']
        fromGlacierRelease = ['GLACIER']
        toGlacierRelease = ['SURFACE_WATER']
        anyCompartment = ['ATMOS_PRECIP','MULTIPLE','CANOPY','ATMOSPHERE','LAKE','SURFACE_WATER',
                          'DEPRESSION','PONDED_WATER','SNOW','SNOW_LIQ','GLACIER_ICE','GLACIER'
                         ]

        #Loops through the number of soil layers chosen by the user. Allows to add the soil[m] to comboboxes
        if self.dlg.combo_soilmod.currentText().lower() == "soil_multilayer":
            numberSoil = int(self.dlg.spin_soilmod.value()) #Get the number of layers
        elif self.dlg.combo_soilmod.currentText().lower() == "soil_two_layers":
            numberSoil = 2
        else:
            numberSoil = 1
        for layer in range(numberSoil):
            compartment = "SOIL["+str(layer)+']'    #Create the string to append to the list
            #Append the soil[m] to the comboboxes
            fromPercolation.append(compartment)
            toPercolation.append(compartment)
            fromCapillaryRise.append(compartment)
            toCapillaryRise.append(compartment)
            fromBaseflow.append(compartment)
            fromInterflow.append(compartment)
            toSeepage.append(compartment)
            anyCompartment.append(compartment)
        for layer in range(numberSoil):
            compartment = "CONVOLUTION["+str(layer)+']' 
            anyCompartment.append(compartment)
        currentWidget = self.dlg.sender()   #Get the widget that was triggered
        index = self.dlg.table_hydroprocess.indexAt(currentWidget.pos())    #Get the index of the widget
        widgetRow = index.row() #Get the row in which the widget is set
        combo_from = QComboBox()    #Initialize the combobox for the from compartment
        combo_to = QComboBox()      #Initialize the combobox for the to compartment
        combo_from.clear()
        combo_to.clear()

        #Sets the value of the compartments based on the selected algorithm
        if isinstance(currentWidget, QComboBox):
            selectedAlg = currentWidget.currentText()
            if selectedAlg in precipalg:
                combo_from.addItems(fromPrecip)
                combo_to.addItems(toPrecip)
            elif selectedAlg in canopevapAlg:
                combo_from.addItems(fromCanevp)
                combo_to.addItems(toCanevp)
            elif selectedAlg in soilevapAlg:
                combo_from.addItems(fromSoilevap)
                combo_to.addItems(toSoilevap) 
            elif selectedAlg in lakeevapAlg:
                combo_from.addItems(fromLakeevap)
                combo_to.addItems(toLakeevap)
            elif selectedAlg in openwaterevapAlg:
                combo_from.addItems(fromOpenwaterevap)
                combo_to.addItems(toOpenwaterevap)
            elif selectedAlg in infiltrationAlg and selectedAlg =='INF_UBC':
                combo_from.addItems(fromInfiltration)
                combo_to.addItems(toInfiltUBC)
            elif selectedAlg in infiltrationAlg and selectedAlg !='INF_UBC':
                combo_from.addItems(fromInfiltration)
                combo_to.addItems(toInfiltration)
            elif selectedAlg in percolationAlg:
                combo_from.addItems(fromPercolation)
                combo_to.addItems(toPercolation)
            elif selectedAlg in cappilaryriseAlg:
                combo_from.addItems(fromCapillaryRise)
                combo_to.addItems(toCapillaryRise)
            elif selectedAlg in baseflowAlg:
                combo_from.addItems(fromBaseflow)
                combo_to.addItems(toBaseflow)
            elif selectedAlg in interflowAlg:
                combo_from.addItems(fromInterflow)
                combo_to.addItems(toInterflow)
            elif selectedAlg in seepageAlg:
                combo_from.addItems(fromSeepage)
                combo_to.addItems(toSeepage)
            elif selectedAlg in depresoverflowAlg:
                combo_from.addItems(fromDepressOverflow)
                combo_to.addItems(toDepressOverflow)
            elif selectedAlg in lakereleaseAlg:
                combo_from.addItems(fromLakeRelease)
                combo_to.addItems(toLakeRelease)
            elif selectedAlg in abstractionAlg:
                combo_from.addItems(fromAbstraction)
                combo_to.addItems(toAbstraction)
            elif selectedAlg == 'SNOBAL_SIMPLE_MELT':
                combo_from.addItems(fromSnowbalSimple)
                combo_to.addItems(toSnowbalSimple)
            elif selectedAlg == 'SNOBAL_COLD_CONTENT':
                combo_from.addItems(fromSnowbalColdcontent)
                combo_to.addItems(toSnowbalColdcontent)
            elif selectedAlg == 'SNOBAL_HBV':
                combo_from.addItems(fromSnowbalHBV)
                combo_to.addItems(toSnowbalHBV)
            elif selectedAlg == 'SNOBAL_TWO_LAYER':
                combo_from.addItems(fromSnowbaltwolayer)
                combo_to.addItems(toSnowbaltwolayer)
            elif selectedAlg == 'SNOBAL_CEMA_NEIGE':
                combo_from.addItems(fromSnowbalCema)
                combo_to.addItems(toSnowbalCema)
            elif selectedAlg == 'SNOBAL_GAWSER':
                combo_from.addItems(fromSnowbalGawser)
                combo_to.addItems(toSnowbalGawser)
            elif selectedAlg == 'SNOBAL_UBC':
                combo_from.addItems(fromSnowbalUBC)
                combo_to.addItems(toSnowbalUBC)
            elif selectedAlg in snowmeltAlg:
                combo_from.addItems(fromSnowmelt)
                combo_to.addItems(toSnowmelt)
            elif selectedAlg in snowrefreezeAlg:
                combo_from.addItems(fromSnowrefreeze)
                combo_to.addItems(toSnowrefreeze)
            elif selectedAlg in sublimationAlg:
                combo_from.addItems(fromSublimation)
                combo_to.addItems(toSublimation)
            elif selectedAlg in canopydripAlg:
                combo_from.addItems(fromCanopydrip)
                combo_to.addItems(toCanopydrip)
            elif selectedAlg in glaciermeltAlg:
                combo_from.addItems(fromGlaciermelt)
                combo_to.addItems(toGlaciermelt)
            elif selectedAlg in glacierreleaseAlg:
                combo_from.addItems(fromGlacierRelease)
                combo_to.addItems(toGlacierRelease)
            elif selectedAlg in flushAlg or selectedAlg in overflowAlg or selectedAlg in splitAlg or selectedAlg in lateralflushAlg or selectedAlg in convolutionAlg:
                combo_from.addItems(anyCompartment)
                combo_to.addItems(anyCompartment)
        self.dlg.table_hydroprocess.setCellWidget(widgetRow, 2, combo_from) #Set the combobox for the from compartment
        self.dlg.table_hydroprocess.setCellWidget(widgetRow, 3, combo_to)   #Set the combobox for the to compartment
        self.dlg.table_hydroprocess.resizeColumnsToContents()   #Resizes automatically the columns
        

    def enableConditionalProc(self):
        basedtype = ['HRU_TYPE','LAND_CLASS','HRU_GROUP']
        comparison = ['IS', 'IS_NOT']
        table = self.dlg.table_hydroprocess
        currentWidget = self.dlg.sender()
        index = self.dlg.table_hydroprocess.indexAt(currentWidget.pos())
        widgetRow = index.row()
        combo_basedtype = QComboBox()
        combo_comparison = QComboBox()
        txt_hrutype = QLineEdit()
        if isinstance(currentWidget, QCheckBox):
            if currentWidget.isChecked():
                combo_basedtype.addItems(basedtype)
                combo_basedtype.setEnabled(True)
                combo_comparison.addItems(comparison)
                combo_comparison.setEnabled(True)
                txt_hrutype.setEnabled(True)
            else:
                combo_basedtype.setEnabled(False)
                combo_comparison.setEnabled(False)
                txt_hrutype.setEnabled(False)
            table.setCellWidget(widgetRow, 5, combo_basedtype)
            table.setCellWidget(widgetRow, 6, combo_comparison)
            table.setCellWidget(widgetRow, 7, txt_hrutype)
            table.resizeColumnsToContents() #Resizes the width of the column automatically


    def addTransportProc(self):
        typelist=['Transport','FixedConcentration','FixedTemperature','MassFlux']
        table = self.dlg.table_transport #Get the hydrologic processes table
        currentRow = table.rowCount()   #Get the number of rows the table has
        table.insertRow(currentRow) #Inserts a new row below the last row
        combo_type = QComboBox()
        txt_constituent = QLineEdit()
        combo_compartment = QComboBox()
        spin_conctemp = QDoubleSpinBox()
        combo_HRUgroup = QComboBox()


        combo_type.addItems(typelist)   #Add a combobox in the new row with all the available processes
        #txt_constituent.setEnabled(False)
        combo_compartment.setEnabled(False)
        spin_conctemp.setEnabled(False)
        combo_HRUgroup.setEnabled(False)
        table.setCellWidget(currentRow, 0, combo_type)
        table.setCellWidget(currentRow, 1, txt_constituent)
        table.setCellWidget(currentRow, 2, combo_compartment)
        table.setCellWidget(currentRow, 3, spin_conctemp)
        table.setCellWidget(currentRow, 4, combo_HRUgroup)
        table.resizeColumnsToContents() #Resizes the width of the column automatically
        combo_type.currentTextChanged.connect(self.setTransportCommands)
    
    def setTransportCommands(self): 
        compartments = ['ATMOS_PRECIP','MULTIPLE','CANOPY','ATMOSPHERE','LAKE','SURFACE_WATER',
                          'DEPRESSION','PONDED_WATER','SNOW','SNOW_LIQ','GLACIER_ICE','GLACIER'
                       ]
        hrugroups = [x.strip() for x in self.dlg.txt_defhru.toPlainText().split(',')]
        currentWidget = self.dlg.sender()
        table = self.dlg.table_transport #Get the transport processes table
        index = self.dlg.table_transport.indexAt(currentWidget.pos())    #Get the index of the widget
        widgetRow = index.row() #Get the row in which the widget is set
        txt_constituent = QLineEdit()
        combo_compartment = QComboBox()
        spin_conctemp = QDoubleSpinBox()
        spin_conctemp.setMinimum(-99999999)
        spin_conctemp.setMaximum(99999999)
        combo_HRUgroup = QComboBox()
        combo_compartment.clear()
        combo_HRUgroup.clear()
        combo_HRUgroup.addItem("")
        if isinstance(currentWidget, QComboBox):
            selectedType = currentWidget.currentText()
            if selectedType == 'Transport':
                txt_constituent.setEnabled(True)
                combo_compartment.setEnabled(False)
                spin_conctemp.setEnabled(False)
                combo_HRUgroup.setEnabled(False)
            elif selectedType == 'FixedConcentration':
                txt_constituent.setEnabled(True)
                combo_compartment.setEnabled(True)
                combo_compartment.addItems(compartments)
                spin_conctemp.setEnabled(True)
                combo_HRUgroup.setEnabled(True)
                combo_HRUgroup.addItems(hrugroups)               
            elif selectedType == 'FixedTemperature':
                txt_constituent.setEnabled(False)
                combo_compartment.setEnabled(True)
                combo_compartment.addItems(compartments)
                spin_conctemp.setEnabled(True)
                combo_HRUgroup.setEnabled(True)
                combo_HRUgroup.addItems(hrugroups)     
            elif selectedType == 'MassFlux':
                txt_constituent.setEnabled(False)
                combo_compartment.setEnabled(True)
                combo_compartment.addItems(compartments)
                spin_conctemp.setEnabled(True)
                combo_HRUgroup.setEnabled(True)
                combo_HRUgroup.addItems(hrugroups)       
        table.setCellWidget(widgetRow, 1, txt_constituent)
        table.setCellWidget(widgetRow, 2, combo_compartment)
        table.setCellWidget(widgetRow, 3, spin_conctemp)
        table.setCellWidget(widgetRow, 4, combo_HRUgroup)
    def rmTransportProc(self):
        table = self.dlg.table_transport
        selectedRow = table.currentRow()
        table.removeRow(selectedRow)
    #This method writes all the parameters entered by the user into the RVI file
    def writeRVI(self):
        '''Gathers all the RVI parameters entered by the user from a dictionary and writes them into a .RVI file
        
            Depends on the following methods:

            getParams()

            getCustomOutput()
        '''
        paramDict = self.getParams()    #Calls the function to retrieve the widgets values
        customOutputList = self.getCustomOutput()   #Calls the function to get the custom output values
        hydroProcessesList = self.getHydroProcess()
        transportProcessesList = self.getTransportProcess()
        outputdir = self.dlg.txt_outputdir.text()   #Get the output directory chosen by the use
        modelName = self.dlg.txt_modname.text()     #Get the name of the model
        disabledhrus_list = paramDict['DisableHRUGroup'].split(',')

        try:
            pathToFolder = outputdir+separator+modelName
            #Creates the RVI file with the name and path provided
            with open(pathToFolder+".rvi","w") as rvi:
                #Writes the parameters from the dictionary
                for key, value in paramDict.items():
                    if value != '' and value != "checked":  #The widget has a value and is not an optional I/O
                        if key == 'DisableHRUGroup':
                            for hru in disabledhrus_list:
                                rvi.write(f':{key:<31} {hru}\n')
                            pass
                        else:
                            rvi.write(f":{key:<30}  {value}\n")
                    elif value == "checked":   #This writes the optional I/O which don't have an argument (so only the key is written)
                        rvi.write(f":{key:<30}\n")
                
                rvi.write(":HydrologicProcesses")
                processCount = 0
                for process in hydroProcessesList:
                    if processCount == 0:
                        rvi.write("\n\t{:<28}".format(':'+process))
                        processCount+=1
                    elif processCount <= 7:
                        if process == 'True':
                            firstcondition = True
                            if firstcondition != False:
                                rvi.write('\n\t   :-->Conditional')
                                firstcondition = False
                                processCount += 1
                            else:
                                rvi.write(' '+ process)
                                processCount += 1
                        elif process =='False' or process == '':
                                processCount +=1
                                pass
                        else:
                            rvi.write(' '+process)
                            processCount +=1 
                    else:
                        processCount = 1
                        rvi.write("\n\t{:<28}".format(':'+process))
                rvi.write("\n:EndHydrologicProcesses\n")

                transportCount = 0
                for transport in transportProcessesList:
                    if transportCount == 0:
                        rvi.write("\n:"+transport)
                        transportCount += 1
                    elif transportCount <= 4 and transportCount != 0:
                        rvi.write(" "+transport)
                        transportCount += 1
                    else:
                        transportCount = 1
                        rvi.write("\n:"+transport)
                

                #Writes the custom output
                count = 0
                rvi.write("{:<33}".format("\n:CustomOutput"))
                for output in customOutputList:
                    if count == 7:
                        count = 0
                        if output == '':
                            count+=1
                            pass
                        else:
                            rvi.write("\n{:<33}".format(":CustomOutput")+output+" ")
                            count+=1
                    else:
                        if output == ' ':
                            count+=1
                            pass
                        else:
                            rvi.write(output + " ")
                            count+=1

            print("RVI file written successfully")
            self.iface.messageBar().pushSuccess("Success", "RVI file written successfully")
        except Exception as e:
            print("Unable to write the RVI file")
            print(e)
            self.iface.messageBar().pushMessage("Error", "Unable to write the RVI file. See python logs for more details.",level=Qgis.Critical)

    #This method gathers all the RVI parameters entered by the user and returns them into a dictionary
    def getParams(self):
        '''Gets all the parameters entered by the user in the Raven RVI tab
        
            Returns a dictionary of parameters
        '''
        #Get the start date
        startDateTmp = self.dlg.date_startdate.dateTime()
        startDate = str(startDateTmp.toPyDateTime())
        #Get the end date or duration
        if self.dlg.chk_duration.isChecked():
            keyDuration = "Duration" 
            duration = str(self.dlg.spin_duration.value())
        else:
            keyDuration = "EndDate"
            endDateTmp = self.dlg.date_enddate.dateTime()
            duration = str(endDateTmp.toPyDateTime())
        #Get the time step
        #timeStepTmp = self.dlg.date_timestep.time()
        #timeStep = str(timeStepTmp.toPyTime())
         
        timestep_h = str("%02d" % self.dlg.spin_timestep_h.value())
        timestep_m = str("%02d" % self.dlg.spin_timestep_m.value())
        timestep_s = str("%02d" % self.dlg.spin_timestep_s.value())
        timeStep = timestep_h + ':'+timestep_m+':'+timestep_s
        #Get soil model
        if self.dlg.combo_soilmod.currentText().lower() == "soil_multilayer":
            soilMod = self.dlg.combo_soilmod.currentText() + ' ' + str(self.dlg.spin_soilmod.value())
        else:
            soilMod = self.dlg.combo_soilmod.currentText()
        #Get Define HRU groups
        defHRUGroups = self.dlg.txt_defhru.toPlainText()
        #Get catchment route
        catchment = self.dlg.combo_catchment.currentText()
        #Get routing
        routing = self.dlg.combo_routing.currentText()
        #Get method
        method= self.dlg.combo_method.currentText()   
        #Get interpolation method
        if self.dlg.combo_interpo.currentText().lower() == "interp_from_file":
            interpolation = self.dlg.combo_interpo.currentText() + ' ' + self.dlg.txt_interpofile.text()
        else:
            interpolation = self.dlg.combo_interpo.currentText()
        #Get evaporation
        evaporation = self.dlg.combo_evapo.currentText()     
        #Get rain snow fraction
        rainsnowfract = self.dlg.combo_rainsnowfrac.currentText()
        #Get OW_Evaporation
        owevapo = self.dlg.combo_owevapo.currentText()
        #Get OroPrecipCorrect
        oroprecip = self.dlg.combo_oroprecip.currentText()
        #Get OroTempCorrect
        orotemp = self.dlg.combo_orotemp.currentText()
        #Get OroPetCorrect
        oropet = self.dlg.combo_oropet.currentText()
        #Get CloudCoverMethod
        cloudcover = self.dlg.combo_cloudcover.currentText()
        #Get AirPressureMethod
        airpressure = self.dlg.combo_airpressure.currentText()
        #Get PotentionMelt
        potmelt = self.dlg.combo_potentialmelt.currentText()
        #Get MonthlyInterpolationMethod
        monthlyinterpo = self.dlg.combo_monthlyinterpo.currentText()
        #Get LakeStorage
        lakestorage = self.dlg.combo_lakestorage.currentText()
        #Get SWRadiationMethod
        swradiation = self.dlg.combo_swradation.currentText()
        #Get SWCanopyCorrect
        swcanopy = self.dlg.combo_swcanopy.currentText()
        #Get SWCloudCorrect
        swcloud = self.dlg.combo_swcloud.currentText()
        #Get LWRadiationMethod
        lwradiation = self.dlg.combo_lwradation.currentText()
        #Get WindSpeedMethod
        windspeed = self.dlg.combo_windspeed.currentText()
        #Get RelativeHumidityMethod
        relhumidity = self.dlg.combo_relhumidity.currentText()
        #Get PrecipIceptFract
        precipicept = self.dlg.combo_precipicept.currentText()
        #Get RechargeMethod
        recharge = self.dlg.combo_recharge.currentText()
        #Get SubdailyMethod
        subdaily = self.dlg.combo_subdaily.currentText()
        #Get Calendar
        calendar = self.dlg.combo_calendar.currentText()
        #Get all the option IO commands
        if self.dlg.chk_runname.isChecked():
            runname = self.dlg.txt_runname.text()
        else:
            runname = ''
        if self.dlg.chk_outputdir.isChecked():
            fileoutputdir = self.dlg.file_outputdir.filePath() 
        else:
            fileoutputdir = ''
        if self.dlg.chk_outputinterval.isChecked():
            outputinterval = self.dlg.spin_outinterval.value()
        else:
            outputinterval = ''
        if self.dlg.chk_rvptemplate.isChecked():
            rvptemplate = "checked"
        else:
            rvptemplate = ''
        if self.dlg.chk_writemassbal.isChecked():
            writemassbal = "checked"
        else:
            writemassbal = ''
        if self.dlg.chk_endpause.isChecked():
            endpause = "checked"
        else:
            endpause = ''
        if self.dlg.chk_writeforcingfunc.isChecked():
            writeforcing = "checked"
        else:
            writeforcing = ''
        if self.dlg.chk_debugmode.isChecked():
            debugmode = "checked"
        else:
            debugmode = ''
        if self.dlg.chk_silentmode.isChecked():
            silentmode = "checked"
        else:
            silentmode = ''
        if self.dlg.chk_writedemand.isChecked():
            writedemand = "checked"
        else:
            writedemand = ''
        if self.dlg.chk_writeenergy.isChecked():
            writeenergy = "checked"
        else:
            writeenergy = ''
        if self.dlg.chk_writeexausmb.isChecked():
            writeexausmb = "checked"
        else:
            writeexausmb = ''
        if self.dlg.chk_writeensim.isChecked():
            writeensim = "checked"
        else:
            writeensim = ''
        if self.dlg.chk_suppressoutput.isChecked():
            suppressoutput = "checked"
        else:
            suppressoutput = ''
        if self.dlg.chk_snaphydro.isChecked():
            snaphydro = "checked"
        else:
            snaphydro = ''
        if self.dlg.chk_wateryear.isChecked():
            wateryear = self.dlg.spin_wateryear.value()
        else:
            wateryear = ''
        if self.dlg.chk_disablehru.isChecked():
            disabledhru = self.dlg.txt_disablehru.toPlainText()
        else:
            disabledhru = ''
        if self.dlg.chk_directevapo.isChecked():
            directevapo = "checked"
        else:
            directevapo = ''
        if self.dlg.chk_snowsuppressespet.isChecked():
            snowsuppressespet = "checked"
        else:
            snowsuppressespet = ''
        if self.dlg.chk_suppresscomppet.isChecked():
            suppresscomppet = "checked"
        else:
            suppresscomppet = ''
        if self.dlg.chk_outputdump.isChecked():
            outputdump = self.dlg.date_outputdump.dateTime()
            outputdump = str(outputdump.toPyDateTime())
        else:
            outputdump = ''
        if self.dlg.chk_rvhfilename.isChecked():
            rvhfilename = self.dlg.txt_rvhfilename.text()
        else:
            rvhfilename = ''
        if self.dlg.chk_rvcfilename.isChecked():
            rvcfilename = self.dlg.txt_rvcfilename.text()
        else:
            rvcfilename = ''
        if self.dlg.chk_rvpfilename.isChecked():
            rvpfilename = self.dlg.txt_rvpfilename.text()
        else:
            rvpfilename = ''
        if self.dlg.chk_rvtfilename.isChecked():
            rvtfilename = self.dlg.txt_rvtfilename.text()
        else:
            rvtfilename = ''
        if self.dlg.chk_reservoirdemandalloc.isChecked():
            reservoirdemandalloc = self.dlg.combo_reservoirdemandalloc.currentText()
        else:
            reservoirdemandalloc = ''
        if self.dlg.chk_chunksize.isChecked():
            chunksize = str(self.dlg.spin_chunksize.value())
        else:
            chunksize = ''
        if self.dlg.chk_readlivefile.isChecked():
            readlivefile = str(self.dlg.spin_readlivefile.value())
        else:
            readlivefile = ''
        if self.dlg.chk_usestopfile.isChecked():
            usestopfile = "checked"
        else:
            usestopfile = ''
        if self.dlg.chk_assimilatestreamflow.isChecked():
            assimilatestreamflow = 'checked'
        else:
            assimilatestreamflow = ''
        if self.dlg.chk_assimilatereservstage.isChecked():
            assimilatereservstage = 'checked'
        else:
            assimilatereservstage = ''
        

        #Writes the selected evaluation metrics
        if not self.dlg.list_evalmetrics.selectedItems(): 
            evalmetrics = ''            #If nothing is selected, assign empty text to the variable to avoid crash
        else:
            firstloop = True
            for item in self.dlg.list_evalmetrics.selectedItems():
                if firstloop != False:
                    evalmetrics = item.text()
                    firstloop = False
                else:
                    evalmetrics= evalmetrics + ' ' + item.text()

        #Create the dictionary
        paramsDict = { 
            "Calendar"                   : calendar,
            "StartDate"                  : startDate,
            keyDuration                  : duration,
            "TimeStep"                   : timeStep,
            "SoilModel"                  : soilMod,
            "DefineHRUGroups"            : defHRUGroups,
            "DisableHRUGroup"            : disabledhru,
            "CatchmentRoute"             : catchment,
            "Routing"                    : routing,
            "Method"                     : method,
            "InterpolationMethod"        : interpolation,
            "Evaporation"                : evaporation,
            "RainSnowFraction"           : rainsnowfract,
            "OW_Evaporation"             : owevapo,
            "OroPrecipCorrect"           : oroprecip,
            "OroTempCorrect"             : orotemp,
            "OroPetCorrect"              : oropet,
            "CloudCoverMethod"           : cloudcover,
            "AirPressureMethod"          : airpressure,
            "PotentialMelt"              : potmelt,
            "MonthlyInterpolationMethod" : monthlyinterpo,
            "LakeStorage"                : lakestorage,
            "SWRadiationMEthod"          : swradiation,
            "SWCanopyCorrect"            : swcanopy,
            "SWCloudCorrect"             : swcloud,
            "LWRadationMethod"           : lwradiation,
            "WindSpeedMethod"            : windspeed,
            "RelativeHumidityMethod"     : relhumidity,
            "PrecipIceptFract"           : precipicept,
            "RechargeMethod"             : recharge,
            "SubdailyMethod"             : subdaily,
            "DirectEvaporation"          : directevapo,
            "SnowSuppressesPET"          : snowsuppressespet,
            "SuppressCompetitivePET"     : suppresscomppet,
            "RunName"                    : runname,
            "OutputDirectory"            : fileoutputdir,
            "OutputInterval"             : outputinterval,
            "CreateRVPTemplate"          : rvptemplate,
            "WaterYearStartMonth"        : wateryear,
            "OutputDump"                 : outputdump,
            "rvh_filename"               : rvhfilename,
            "rvc_filename"               : rvcfilename,
            "rvp_filename"               : rvpfilename,
            "rvt_filename"               : rvtfilename,
            "ReservoirDemandAllocation"  : reservoirdemandalloc,
            "Chunksize"                  : chunksize,
            "ReadLiveFile"               : readlivefile,
            "WriteMassBalanceFile"       : writemassbal,
            "writeForcingFunctions"      : writeforcing,
            "EndPause"                   : endpause,
            "DebugMode"                  : debugmode,
            "SilentMode"                 : silentmode,
            "WriteDemandFile"            : writedemand,
            "WriteEnergyStorage"         : writeenergy,
            "WriteExhaustiveMB"          : writeexausmb,
            "WriteEnsimFormat"           : writeensim,
            "SuppressOutput"             : suppressoutput,
            "SnapshotHydrograph"         : snaphydro,
            "UseStopFile"                : usestopfile,
            "AssimilateStreamflow"       : assimilatestreamflow,
            "AssimilateReservoirStage"   : assimilatereservstage,
            "EvaluationMetrics"          : evalmetrics
        }
        return paramsDict



    def getHydroProcess(self):
        table = self.dlg.table_hydroprocess
        rows = table.rowCount()
        cols = table.columnCount()
        processesList = []
        for row in range(rows):
            for col in range(cols):
                currentWidget = table.cellWidget(row,col)
                if isinstance(currentWidget, QComboBox):
                    processesList.append(currentWidget.currentText())
                elif isinstance(currentWidget, QCheckBox):
                    if currentWidget.isChecked():
                        processesList.append('True')
                    else:
                        processesList.append('False')
                elif isinstance(currentWidget, QLineEdit):
                    processesList.append(currentWidget.text().upper())
        return processesList


    def getTransportProcess(self):
        table = self.dlg.table_transport
        rows = table.rowCount()
        cols = table.columnCount()
        processesList = []

        for row in range(rows):
            for col in range(cols):
                currentWidget = table.cellWidget(row,col)
                if isinstance(currentWidget, QComboBox):
                    processesList.append(currentWidget.currentText())
                elif isinstance(currentWidget,QLineEdit):
                    processesList.append(currentWidget.text())
                elif isinstance(currentWidget,QDoubleSpinBox):
                    if currentWidget.isEnabled():
                        processesList.append(str(currentWidget.value()))
                    else:
                        processesList.append("")        
        return processesList


    #This method fetches the custom output widgets' values and returns them into a list
    def getCustomOutput(self):
        '''Loops through all the custom output widgets to retrieve their values
        
           Returns a list
        '''
        #Get the values of the comboboxes
        timeperiod1 = self.dlg.combo_time1.currentText()
        timeperiod2 = self.dlg.combo_time2.currentText()
        timeperiod3 = self.dlg.combo_time3.currentText()
        timeperiod4 = self.dlg.combo_time4.currentText()
        timeperiod5 = self.dlg.combo_time5.currentText()
        timeperiod6 = self.dlg.combo_time6.currentText()
        timeperiod7 = self.dlg.combo_time7.currentText()
        combostat1 = self.dlg.combo_stat1.currentText()
        combostat2 = self.dlg.combo_stat2.currentText()
        combostat3 = self.dlg.combo_stat3.currentText()
        combostat4 = self.dlg.combo_stat4.currentText()
        combostat5 = self.dlg.combo_stat5.currentText()
        combostat6 = self.dlg.combo_stat6.currentText()
        combostat7 = self.dlg.combo_stat7.currentText()

        #Sets an empty string for the spinboxes if the statistic is not histogram. Otherwise, gets the value of the spinboxes
        if combostat1 != 'HISTOGRAM':
            spinmin1 = ''
            spinmax1 = ''
            spinbin1 = ''
        else:
            spinmin1 = str(self.dlg.spin_min1.value())
            spinmax1 = str(self.dlg.spin_max1.value())
            spinbin1 = str(self.dlg.spin_bin1.value())
        
        if combostat2 != 'HISTOGRAM':
            spinmin2 = ''
            spinmax2 = ''
            spinbin2 = ''
        else:
            spinmin2 = str(self.dlg.spin_min1.value())
            spinmax2 = str(self.dlg.spin_max1.value())
            spinbin2 = str(self.dlg.spin_bin1.value())
                    
        if combostat3 != 'HISTOGRAM':
            spinmin3 = ''
            spinmax3 = ''
            spinbin3 = ''
        else:
            spinmin3 = str(self.dlg.spin_min1.value())
            spinmax3 = str(self.dlg.spin_max1.value())
            spinbin3 = str(self.dlg.spin_bin1.value())
        
        if combostat4 != 'HISTOGRAM':
            spinmin4 = ''
            spinmax4 = ''
            spinbin4 = ''
        else:
            spinmin4 = str(self.dlg.spin_min1.value())
            spinmax4 = str(self.dlg.spin_max1.value())
            spinbin4 = str(self.dlg.spin_bin1.value())

        if combostat5 != 'HISTOGRAM':
            spinmin5 = ''
            spinmax5 = ''
            spinbin5 = ''
        else:
            spinmin5 = str(self.dlg.spin_min1.value())
            spinmax5 = str(self.dlg.spin_max1.value())
            spinbin5 = str(self.dlg.spin_bin1.value())
        
        if combostat6 != 'HISTOGRAM':
            spinmin6 = ''
            spinmax6 = ''
            spinbin6 = ''
        else:
            spinmin6 = str(self.dlg.spin_min1.value())
            spinmax6 = str(self.dlg.spin_max1.value())
            spinbin6 = str(self.dlg.spin_bin1.value())
        
        if combostat7 != 'HISTOGRAM':
            spinmin7 = ''
            spinmax7 = ''
            spinbin7 = ''
        else:
            spinmin7 = str(self.dlg.spin_min1.value())
            spinmax7 = str(self.dlg.spin_max1.value())
            spinbin7 = str(self.dlg.spin_bin1.value())
        #Gets the variable value
        txtvariable1 = self.dlg.txt_var1.text() 
        txtvariable2 = self.dlg.txt_var2.text() 
        txtvariable3 = self.dlg.txt_var3.text() 
        txtvariable4 = self.dlg.txt_var4.text() 
        txtvariable5 = self.dlg.txt_var5.text() 
        txtvariable6 = self.dlg.txt_var6.text() 
        txtvariable7 = self.dlg.txt_var7.text() 
        #Gets the combobox the spatial evaluation 
        comboeval1 = self.dlg.combo_eval1.currentText()
        comboeval2 = self.dlg.combo_eval2.currentText()
        comboeval3 = self.dlg.combo_eval3.currentText()
        comboeval4 = self.dlg.combo_eval4.currentText()
        comboeval5 = self.dlg.combo_eval5.currentText()
        comboeval6 = self.dlg.combo_eval6.currentText()
        comboeval7 = self.dlg.combo_eval7.currentText()
        #Creates the list containing all the custom output information
        customOutputList = [ timeperiod1, combostat1, spinmin1, spinmax1, spinbin1, txtvariable1,comboeval1,
                             timeperiod2, combostat2, spinmin2, spinmax2, spinbin2,txtvariable2,comboeval2,
                             timeperiod3, combostat3, spinmin3, spinmax3, spinbin3,txtvariable3,comboeval3,
                             timeperiod4, combostat4, spinmin4, spinmax4, spinbin4,txtvariable4,comboeval4,
                             timeperiod5, combostat5, spinmin5, spinmax5, spinbin5,txtvariable5,comboeval5,
                             timeperiod6, combostat6, spinmin6, spinmax6, spinbin6,txtvariable6,comboeval6,
                             timeperiod7, combostat7, spinmin7, spinmax7, spinbin7,txtvariable7,comboeval7,
                           ]
        # #Loop through all the Custom Ouput widgets in order to get their values and add them to a list
        # for i in range(self.dlg.gridLayout.count()):
        #     if isinstance(self.dlg.gridLayout.itemAt(i).widget(),QComboBox):    #Get the combobox values
        #         if self.dlg.gridLayout.itemAt(i).widget().currentText() != '':
        #             customOutputList.append(self.dlg.gridLayout.itemAt(i).widget().currentText())
        #         else: 
        #             customOutputList.append(" ")    #If the combobox is empty, places an empty space at its place in the list
        #     elif isinstance(self.dlg.gridLayout.itemAt(i).widget(),QSpinBox):
        #         if self.dlg.gridLayout.itemAt(i).widget().isEnabled() == True:
        #             customOutputList.append(str(self.dlg.gridLayout.itemAt(i).widget().value()))
        #         else:
        #             customOutputList.append(" ")
        #     else:
        #         if self.dlg.gridLayout.itemAt(i).widget().text() != '': #Get the line edit values
        #             customOutputList.append(self.dlg.gridLayout.itemAt(i).widget().text())
        #         else: 
        #             customOutputList.append(" ") #If the line edit is empty, places an empty space at its place in the list
        # print(customOutputList)
        


        return customOutputList 

    #This method gets all the RVH parameters and returns them into a dictionary
    def getRVHparams(self):
        '''Gathers all the values entered by the user inside the BasinMaker RVH tab
        
            Returns a dictionary of parameters
        '''
        pathdem = self.dlg.file_dem.filePath()  #Get the path to the DEM
        pathlandusepoly = self.dlg.file_landusepoly.filePath()  #Get the path to the landuse polygon
        pathlanduserast = self.dlg.file_landuserast.filePath()  #Get the path to the landuse raster
        if pathlanduserast =='':
            pathlanduserast = '#'
        pathlakes = self.dlg.file_lakes.filePath()  #Get the path to the lakes polygon
        if pathlakes == '': #Since the lakes are optional, assign a value so the parameter is still written. 
            pathlakes = '#' #This allows to make a check in the create_RVH.py
        pathbankfull = self.dlg.file_bankfullwidth.filePath()   #Get the path to the bankfull width file
        if pathbankfull == '':
            pathbankfull = '#'
        pathsoil = self.dlg.file_soil.filePath()    #Get the path to the soil file
        pathpointsinterest = self.dlg.file_pointsinterest.filePath()    #Get the path to the points of interest file
        maxmemory = self.dlg.spin_ram.value()   #Get the max RAM for BasinMaker to use
        
        if self.dlg.rb_modedem.isChecked(): #If the mode using_DEM
            extentMode = "using_dem"
            path_hybasin = ''
            hybasinid = ''
            bufferdistance = ''
            outletlat = ''
            outletlon = ''
            path_providedpoly = ''
        elif self.dlg.rb_modehybasin.isChecked():   #If the mode is using_hybasin
            extentMode = "using_hybasin"
            path_hybasin = self.dlg.file_hybasin.filePath()
            hybasinid   = str(self.dlg.txt_hybasin.text())
            bufferdistance = str(self.dlg.spin_buffer.value())
            outletlat = ''
            outletlon = ''
            path_providedpoly = ''
        elif self.dlg.rb_outletpt.isChecked():  #If the mode is using_outlet_pt
            extentMode = "using_outlet_pt"
            outletlat = self.dlg.txt_outletlat.text()
            outletlon = self.dlg.txt_outletlon.text()
            path_hybasin = ''
            hybasinid = ''
            bufferdistance = ''
            path_providedpoly = ''
        elif self.dlg.rb_providedply.isChecked():   #If the mode is using_provided_ply
            extentMode = "using_provided_ply"
            path_providedpoly = self.dlg.file_providedply.filePath()
            bufferdistance = str(self.dlg.spin_buffer.value())
            path_hybasin = ''
            hybasinid = ''
            outletlat = ''
            outletlon = ''
        
        if self.dlg.file_lakes.filePath():    #If there is a layer for the lakes, gather the values needed. Else, assign empty values
            lakeid = self.dlg.combo_lakeid.currentText()
            laketype = self.dlg.combo_laketype.currentText()
            lakevol = self.dlg.combo_lakevol.currentText()
            lakeavgdepth = self.dlg.combo_lakeavgdepth.currentText()
            lakearea = self.dlg.combo_lakearea.currentText()
            connectedlake = self.dlg.spin_conlakearea.value()
            nonconnectedlake = self.dlg.spin_nonconlakearea.value()
            print('went in the non empty values')
        else:
            lakeid = '#'
            laketype = '#'
            lakevol = '#'
            lakeavgdepth = '#'
            lakearea = '#'
            connectedlake = '#'
            nonconnectedlake = '#'

        poiid = self.dlg.combo_poiid.currentText()   #Get the id field of the point of interest
        poiname = self.dlg.combo_poiname.currentText()   #Get the name field of the point of interest
        poidrainarea = self.dlg.combo_poidrainarea.currentText() #Get the drainage area field of the point of interest
        poisource = self.dlg.combo_poisource.currentText()   #Get the source field of the point of interest

        if self.dlg.chk_epsgcode.isChecked():   #Get the EPSG code if the checkbox is checkedm
            epsgcode = 'EPSG:'+self.dlg.txt_epsgcode.text()
        else:                                   #Otherwise use the default value of BasinMaker
            epsgcode = 'EPSG:3573'

        if self.dlg.file_bankfullwidth.filePath():  #If there is a layer for Bankfull width, gather the values needed
            bankfullwidth = self.dlg.combo_bankfullwidth.currentText()
            bankfulldepth = self.dlg.combo_bankfulldepth.currentText()
            bankfulldischarge = self.dlg.combo_bankfulldischarge.currentText()
            bankfulldrainage = self.dlg.combo_bankfulldrainarea.currentText()
            kcoef = ''
            ccoef = ''
        else:  
            bankfullwidth = ''
            bankfulldepth = ''
            bankfulldischarge = ''
            bankfulldrainage = ''
            kcoef = str(self.dlg.spin_kcoef.value())
            ccoef = str(self.dlg.spin_ccoef.value())

        if self.dlg.file_landuserast.filePath():    #If a landuse raster is provided, get its path
            landusemanning = self.dlg.file_landusemanning.filePath()
        else:
            landusemanning = '#'
        if self.dlg.rb_fdr.isChecked():  #If the delineation mode is using_fdr, get the flow direction file path
            delineatemode = "using_fdr"
            pathfdr = self.dlg.file_fdr.filePath()
        elif self.dlg.rb_dem.isChecked(): #If the delineation mode is using_dem, assign an empty value to the fdr path
            delineatemode = "using_dem"
            pathfdr = ''
        facthreshold = self.dlg.spin_facthreshold.value()   #Get the flow accumulation threshold value
        
        #Postprocessing parameters
        filterconnectedlakes = self.dlg.spin_filterconnectedlakes.value()  #Get the connected lake area threshold value
        filternonconnectedlakes = self.dlg.spin_filternonconnectedlakes.value() #Get the non connected lake area threshold value
        if self.dlg.txt_selectedlakeid.text() != '':    #Get selected lake ids if they are provided
            selectedlakeid = self.dlg.txt_selectedlakeid.text().replace(" ","")
        else:
            selectedlakeid = '#'
        minsubbasinarea = self.dlg.spin_minsubbasinarea.value() #Get the minimum subbasin area value
        pathlanduseinfo = self.dlg.file_pathlanduseinfo.filePath()  #Get the landuse csv file path
        pathsoilinfo = self.dlg.file_pathsoilinfo.filePath()    #Get the soil csv file path
        pathveginfo = self.dlg.file_pathveginfo.filePath()  #Get the vegetation csv file path
        modelname = self.dlg.txt_modelname.text()   #Get the name of the model

        #Create the RVH parameters dictionary
        params = {
            "pathdem"                   : pathdem,
            "pathlandusepoly"           : pathlandusepoly,
            "pathlanduserast"           : pathlanduserast,
            "pathlakes"                 : pathlakes,
            "pathbankfull"              : pathbankfull,
            "pathsoil"                  : pathsoil,
            "pathpointsinterest"        : pathpointsinterest,
            "maxmemory"                 : maxmemory,
            "extentmode"                : extentMode,
            "pathhybasin"               : path_hybasin,
            "hybasinid"                 : hybasinid,
            "bufferdistance"            : bufferdistance,
            "outletlat"                 : outletlat,
            "outletlon"                 : outletlon,
            "path_providedpoly"         : path_providedpoly,
            "lakeid"                    : lakeid,
            "laketype"                  : laketype,
            "lakevol"                   : lakevol,
            "lakeavgdepth"              : lakeavgdepth,
            "lakearea"                  : lakearea,
            "connectedlake"             : connectedlake,
            "nonconnectedlake"          : nonconnectedlake,
            "poiid"                     : poiid,
            "poiname"                   : poiname,
            "poidrainarea"              : poidrainarea,
            "poisource"                 : poisource,
            "epsgcode"                  : epsgcode,
            "bankfullwidth"             : bankfullwidth,
            "bankfulldepth"             : bankfulldepth,
            "bankfulldischarge"         : bankfulldischarge,
            "bankfulldrainage"          : bankfulldrainage,
            "kcoef"                     : kcoef,
            "ccoef"                     : ccoef,
            "landusemanning"            : landusemanning,
            "facthreshold"              : facthreshold,
            "delineatemode"             : delineatemode,
            "pathfdr"                   : pathfdr,
            "filterconnectedlakes"      : filterconnectedlakes,
            "filternonconnectedlakes"   : filternonconnectedlakes,
            "selectedlakeid"            : selectedlakeid,
            "minsubbasinarea"           : minsubbasinarea,
            "pathlanduseinfo"           : pathlanduseinfo,
            "pathsoilinfo"              : pathsoilinfo,
            "pathveginfo"               : pathveginfo,
            "modelname"                 : modelname
        }
        return params

    #This method exports the paramters dictionary into a file. This file is then used by the docker container
    #to run BasinMaker using the parameters from the file
    def exportRVHparams(self,paramDict):
        '''Exports the RVH parameters dictionary into a .txt file stored inside a directory provided by the user'''
        outputdir = self.dlg.file_outputfolder.filePath()   #Get the output directory
        try:
            #Path where to save the parameters file
            pathToFolder = outputdir+separator+ "parameters"
            #Creates the rvh parameters file with path provided
            with open(pathToFolder+".txt","w") as file:
                #Writes the parameters from the dictionary
                for key, value in paramDict.items():
                    if value != '':
                        file.write(f"{key:<30}  {value}\n")
            print("Successfully exported the RVH parameters")
        except Exception as e:
            print("Could not export the BasinMaker parameters")
            print(e)


    def loadAttributes(self):
        widget = self.dlg.sender()
        widgetname = widget.objectName()
        if widgetname == 'file_lakes': 
            lakespath = self.dlg.file_lakes.filePath()
            vlayer = QgsVectorLayer(lakespath, "lakes", "ogr")
            if not vlayer.isValid():
                print("Layer failed to load!")
            else:
                field_names = vlayer.fields().names()
                self.dlg.combo_lakeid.clear()
                self.dlg.combo_lakeid.addItem('LAKE ID - required')
                self.dlg.combo_lakeid.addItems(field_names)
                self.dlg.combo_laketype.clear()
                self.dlg.combo_laketype.addItem('LAKE TYPE')
                self.dlg.combo_laketype.addItems(field_names)
                self.dlg.combo_lakeavgdepth.clear()
                self.dlg.combo_lakeavgdepth.addItem('AVERAGE DEPTH (m)')
                self.dlg.combo_lakeavgdepth.addItems(field_names)
                self.dlg.combo_lakearea.clear()
                self.dlg.combo_lakearea.addItem('AREA OF LAKES (km2) - required')
                self.dlg.combo_lakearea.addItems(field_names)
                self.dlg.combo_lakevol.clear()
                self.dlg.combo_lakevol.addItem('VOLUME OF LAKES (km3) - required')
                self.dlg.combo_lakevol.addItems(field_names)
        elif widgetname == 'file_pointsinterest':
            poipath = self.dlg.file_pointsinterest.filePath()
            vlayer = QgsVectorLayer(poipath, "poi", "ogr")
            if not vlayer.isValid():
                print("Layer failed to load!")
            else:
                field_names = vlayer.fields().names()
                self.dlg.combo_poiid.clear()
                self.dlg.combo_poiid.addItem('ID - required')
                self.dlg.combo_poiid.addItems(field_names)
                self.dlg.combo_poiname.clear()
                self.dlg.combo_poiname.addItem('UNIQUE NAME')
                self.dlg.combo_poiname.addItems(field_names)
                self.dlg.combo_poidrainarea.clear()
                self.dlg.combo_poidrainarea.addItem('DRAINAGE AREA - required')
                self.dlg.combo_poidrainarea.addItems(field_names)
                self.dlg.combo_poisource.clear()
                self.dlg.combo_poisource.addItem('SOURCE OF OBSERVATION')
                self.dlg.combo_poisource.addItems(field_names)      
        elif widgetname == 'file_bankfullwidth':
            bankfullpath = self.dlg.file_bankfullwidth.filePath()
            vlayer = QgsVectorLayer(bankfullpath, "bkfw", "ogr")
            if not vlayer.isValid():
                print("Layer failed to load!")
            else:
                field_names = vlayer.fields().names()
                self.dlg.combo_bankfullwidth.clear()
                self.dlg.combo_bankfullwidth.addItem('BANKFULL WIDTH (m) - required')
                self.dlg.combo_bankfullwidth.addItems(field_names)
                self.dlg.combo_bankfulldepth.clear()
                self.dlg.combo_bankfulldepth.addItem('BANKFULL DEPTH (m) - required')
                self.dlg.combo_bankfulldepth.addItems(field_names)
                self.dlg.combo_bankfulldischarge.clear()
                self.dlg.combo_bankfulldischarge.addItem('ANNUAL MEAN DISCHARGE (m3/s) - required')
                self.dlg.combo_bankfulldischarge.addItems(field_names)
                self.dlg.combo_bankfulldrainarea.clear()
                self.dlg.combo_bankfulldrainarea.addItem('DRAINAGE AREA (km2) - required')
                self.dlg.combo_bankfulldrainarea.addItems(field_names)   


        elif widgetname == 'file_netcdf':
            netcdfpath = self.dlg.file_netcdf.filePath()
            vlayer = QgsVectorLayer(netcdfpath, "netcdf", "ogr")
            if not vlayer.isValid():
                print("Layer failed to load!")
            else:
                field_names = vlayer.fields().names()
                self.dlg.combo_ncattributes.clear()
                self.dlg.combo_ncattributes.addItems(field_names)             
            
    #This method sets up the scriptbash/basinmaker docker container. Pulls, starts and stops the docker container
    def dockerinit(self):
        '''Runs multiple methods related to Docker. Basically manages the Docker setup
        
            Depends on the following methods:

            getRVHparams()

            exportRVHparams()

            dockerPull()

            dockerStart()

            dockerCopy()

            runBasinMaker()

            getDockerResults()
         '''
        pythonConsole = self.iface.mainWindow().findChild(QDockWidget, 'PythonConsole')
        if not pythonConsole or not pythonConsole.isVisible():  #If the python console is closed, open it
            self.iface.actionShowPythonDialog().trigger()       #It allows the user to see the BasinMaker progress
        self.iface.messageBar().pushInfo("Info", "The BasinMaker process is starting, this will take a while to complete.")
        self.iface.mainWindow().repaint()
        paramsDict = self.getRVHparams()    #Calls the function to get the RVH parameters
        self.exportRVHparams(paramsDict)    #Calls the function to export the RVH parameters into a file
        self.dockerPull()                   #Calls the function to pull the container
        self.dockerStart()                  #Calls the function that starts the container
        self.dockerCopy(paramsDict)         #Calls the function that copies the parameters file to the docker container, as well as the data
        self.runBasinMaker()                #Calls the function that runs BasinMaker with the provided data and parameters
        self.getDockerResults()             #Calls the function that retrieves the results from BasinMaker
        os.system("docker stop qraven")     #Stops the container after the process
        os.system("docker rm qraven")       #Deletes the container

      
    #This method fully removes the container, as well as the image to free up space
    def dockerdelete(self):
        '''Stops the Docker container, removes it as well as the image'''
        try:
            print("Making sure the container is stopped > docker stop qraven")
            os.system("docker stop qraven")
            print("Removing the docker container > docker rm qraven")
            os.system("docker rm qraven")
            print("Removing the image > docker rmi scriptbash/qraven")
            os.system("docker rmi scriptbash/qraven")
            print("container stopped and removed")
            self.iface.messageBar().pushSuccess("Success", "The docker container and the image were removed")
        except Exception as e:
            print("An error occured while attempting to remove the docker container and image")
            print(e)


    #This method pulls the scriptbash/qraven docker container
    def dockerPull(self):
        '''Pulls the scriptbash/qraven docker container
        
            Depends on the following method:

            dockerCommand()
        '''
        try:
            print("Trying to pull the scriptbash/qraven image...")
            cmd='docker', 'pull', 'scriptbash/qraven:latest'  
            self.dockerCommand(cmd)
            print("The pull was successfull")
        except Exception as e:
            print(e)
    

    #This method starts the docker container
    def dockerStart(self):
        '''Starts the docker container detached, with a pseudo-tty. The working directory is /root/BasinMaker
        
            Depends on the following method:

            dockerCommand()
        '''
        try:
            print("Attempting to start the container...")
            cmd='docker', 'run', '-t', '-d','-w','/root/BasinMaker','--name', 'qraven', 'scriptbash/qraven'
            self.dockerCommand(cmd)
            print("The container was started successfully")
        except Exception as e:
            print(e)

    #This method copies the RVH parameters file and the user's data to the docker container
    def dockerCopy(self,params):
        '''Copy the RVH parameters file and the user's geospatial data to the Docker container'''
        outputdir = self.dlg.file_outputfolder.filePath()   #Get the output directory
        dockerBMpath = '/root/BasinMaker'   #The path to the BasinMaker folder inside the container 
        dockerDEMPath = dockerBMpath + '/Data/DEM'  #The path to the DEM folder inside the container
        dockerLandusePath = dockerBMpath + '/Data/landuse'  #The path to the landuse folder inside the container
        dockerLakesPath = dockerBMpath + '/Data/lakes'  #The path to the lakes folder inside the container
        dockerBankfullPath = dockerBMpath + '/Data/bkf_width'   #The path to the bkf_width folder inside the container
        dockerSoilPath = dockerBMpath + '/Data/soil'    #The path to the soil folder inside the container
        dockerPoIPath = dockerBMpath + '/Data/stations' #The path to the point of interest folder inside the container
        dockerHybasinPath = dockerBMpath + '/Data/hybasin'  #The path to the hydro basin folder inside the container
        dockerProvPolyPath = dockerBMpath + '/Data/extent_poly' #The path to the extent polygon folder inside the container
        dockerFDRPath = dockerBMpath + '/Data/flow_direction'   #The path to the flow direction folder inside the container
        
        #Dictionary of the data path provided by the user
        datapaths = {
            'dem'               : params['pathdem'],
            'landusepoly'       : params['pathlandusepoly'],
            'landuserast'       : params['pathlanduserast'],
            'lakes'             : params['pathlakes'],
            'bankfull'          : params['pathbankfull'],
            'soil'              : params['pathsoil'],
            'pointinterest'     : params['pathpointsinterest'],
            'hybasin'           : params['pathhybasin'],
            'provpoly'          : params['path_providedpoly'],
            'manning'           : params['landusemanning'],
            'flowdirection'     : params['pathfdr'],
            'landuseinfo'       : params['pathlanduseinfo'],
            'soilinfo'          : params['pathsoilinfo'],
            'veginfo'           : params['pathveginfo']

        }
        shpExt = ['cfg', 'dbf', 'prj','qmd','shp', 'shx']   #List with the shapefile extensions
        rvhScript = outputdir+separator+ "parameters.txt"   #Get the path to the exported parameters file
        cmd='docker', 'cp', rvhScript, 'qraven:'+ dockerBMpath
        self.dockerCommand(cmd)
        
        #Loop through the dictionary of paths
        for key, path in datapaths.items():
            if path != '' or path != '#':   #If the path has a file provided
                filename = Path(path).stem  #Get the file name without extension and path
                folder = os.path.dirname(path)  #Get only the file path (without the file name)
                if key == 'dem':
                    cmdData='docker', 'cp', params['pathdem'], 'qraven:'+ dockerDEMPath
                    self.dockerCommand(cmdData) #Sends the DEM to the container
                elif key == 'landusepoly':
                    for extension in shpExt:
                        file = folder+separator+filename + '.' + extension
                        cmdData='docker', 'cp', file, 'qraven:'+ dockerLandusePath
                        self.dockerCommand(cmdData) #Sends the complete landuse polygon shapefile to the container
                elif key == 'landuserast':
                    cmdData='docker', 'cp', params['pathlanduserast'], 'qraven:'+ dockerLandusePath
                    self.dockerCommand(cmdData) #Sends the landuse raster to the container
                elif key == 'lakes':
                    for extension in shpExt:
                        file = folder+separator+filename + '.' + extension
                        cmdData='docker', 'cp', file, 'qraven:'+ dockerLakesPath
                        self.dockerCommand(cmdData) #Sends the complete lakes shapefile to the container
                elif key == 'bankfull':
                    for extension in shpExt:
                        file = folder+separator+filename + '.' + extension
                        cmdData='docker', 'cp', file, 'qraven:'+ dockerBankfullPath
                        self.dockerCommand(cmdData) #Sends the complete bankfull width shapefile to the container
                elif key == 'soil':
                    for extension in shpExt:
                        file = folder+separator+filename + '.' + extension
                        cmdData='docker', 'cp', file, 'qraven:'+ dockerSoilPath
                        self.dockerCommand(cmdData)     #Sends the complete soil shapefile to the container
                elif key == 'pointinterest':
                    for extension in shpExt:
                        file = folder+separator+filename + '.' + extension
                        cmdData='docker', 'cp', file, 'qraven:'+ dockerPoIPath
                        self.dockerCommand(cmdData) #Sends the complete point of interest shapefile to the container
                elif key == 'hybasin':
                    for extension in shpExt:
                        file = folder+separator+filename + '.' + extension
                        cmdData='docker', 'cp', file, 'qraven:'+ dockerHybasinPath
                        self.dockerCommand(cmdData) #Sends the complete hydro basin shapefile to the container
                elif key == 'provpoly':
                    for extension in shpExt:
                        file = folder+separator+filename + '.' + extension
                        cmdData='docker', 'cp', file, 'qraven:'+ dockerProvPolyPath
                        self.dockerCommand(cmdData) #Sends the complete extent polygon shapefile to the container
                elif key == 'manning':
                    for extension in shpExt:
                        cmdData='docker', 'cp', params['landusemanning'], 'qraven:'+ dockerLandusePath
                        self.dockerCommand(cmdData) #Sends the landuse manning table to the container
                elif key == 'flowdirection':
                    for extension in shpExt:
                        cmdData='docker', 'cp', params['pathfdr'], 'qraven:'+ dockerFDRPath
                        self.dockerCommand(cmdData)  #Sends flow direction file to the container
                elif key == 'landuseinfo':
                    cmdData='docker', 'cp', params['pathlanduseinfo'], 'qraven:'+ dockerLandusePath
                    self.dockerCommand(cmdData)     #Sends landuse info csv file to the container
                elif key == 'soilinfo':
                    cmdData='docker', 'cp', params['pathsoilinfo'], 'qraven:'+ dockerSoilPath
                    self.dockerCommand(cmdData) #Sends soil info csv file to the container
                elif key == 'veginfo':
                    cmdData='docker', 'cp', params['pathveginfo'], 'qraven:'+ dockerLandusePath
                    self.dockerCommand(cmdData) #Sends vegetation csv file to the container

        print("Done copying the files to the container")  


    #This method runs the command that it receives with subprocess
    def dockerCommand(self,cmd): 
        '''Executes the command it receives with subprocess.Popen
        
            param cmd: The command to run (string or tuple)
        ''' 
        if computerOS == 'windows':
            startupinfo = subprocess.STARTUPINFO()
            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
            startupinfo.wShowWindow = subprocess.SW_HIDE
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE,startupinfo=startupinfo)
        else:
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE)
        while True:
            output = process.stdout.readline()
            if output == b'':
                break
            if output:
                print(output.strip().decode("utf-8","ignore").replace('',''))  #Surely there's a better way to remove the %08 character (shows as BS in str format)
        rc = process.poll()      


    #This method starts the create_RVH.py script
    def runBasinMaker(self):
        '''Launches the create_RVH.py script inside the Docker container.
            Uses the bash shell in interactive mode in order to get the proper python paths and 
            environment variables set in ~/.bashrc.

            Depends on the following method:

            dockerCommand()
        '''
        print("Starting BasinMaker process, this will take a while to complete")
        pythoncmd = "python3 -u create_RVH.py"  #Bash command to start the BasinMaker script
        cmd ='docker', 'exec','-t', 'qraven','/bin/bash','-i','-c',pythoncmd    #Docker command to run the script
        try:
            os.system("docker start qraven")    #Make sure the container is started. Only needed when the plugin is run a second time
            self.dockerCommand(cmd)
            print("BasinMaker has finished processing the files")  
        except Exception as e:
            print("The BasinMaker process failed...")
            print(e)
        

    #This method retrieves the results folder generated by BasinMaker and saves it in the user's output directory
    def getDockerResults(self):
        '''Grabs the OIH_Output folder from the Docker container and places it into the user's specified directory
        
            Depends on the following method:

            dockerCommand()
        '''
        outputdir = self.dlg.file_outputfolder.filePath()   #Get the output directory
        dockerBMResultsPath = '/root/BasinMaker/OIH_Output' #Get the docker path where the results are
        print("Grabbing the results, this could take a while...")
        cmd ='docker', 'cp','qraven:'+dockerBMResultsPath, outputdir
        try:
            self.dockerCommand(cmd)
            print("The results are now in " + outputdir) 
        except Exception as e:
            print("Failed to retrieve the results...")
            print(e)
        try:    
            hrulayer = QgsVectorLayer(outputdir+separator+"OIH_Output"+separator+"network_after_gen_hrus"+separator+"finalcat_hru_info.shp", 'finalcat_hru_info', "ogr")
            lakelayer = QgsVectorLayer(outputdir+separator+"OIH_Output"+separator+"network_after_gen_hrus"+separator+"finalcat_hru_lake_info.shp", 'finalcat_hru_lake_info', "ogr")
            QgsProject.instance().addMapLayer(hrulayer)  #Adds the HRU layer to the QGIS map
            QgsProject.instance().addMapLayer(lakelayer) #Add the HRU lakes layer to the QGIS map           
        except Exception as e:
            print("Failed to load the results shapefile...")
            print(e)
        self.iface.messageBar().pushInfo("Info", "The BasinMaker process has finished. Check the python logs for more details.")


    def generateGridWeights(self):
        # if netcdf_installed == True:
        #     try:
        #         fn = "/home/francis/Documents/Geoinfo/precip_exp.nc"
        #         ds = nc.Dataset(fn)
        #         print(ds)
        #     except Exception as e:
        #         print("Couldn't open the netCDF file...")
        #         print(e)
        # else:
        #     self.iface.messageBar().pushMessage("Error", "Please install the netCDF4 python library to use this feature",level=Qgis.Critical)
        #     print('The netCDF4 library could not be found. Please install it before using this feature.')

        ncfile = self.dlg.file_netcdf.filePath()
        ncfilename = ntpath.basename(ncfile)  #Get the file name with extension
        foldernc = os.path.dirname(ncfile)  #Get only the file path (without the file name)
        ncextension = os.path.splitext(ncfilename)[1]
        volumenc = foldernc+':/root/Gridweights/nc/'
        hrusfile = self.dlg.file_hrus.filePath()
        hrusfilename = ntpath.basename(hrusfile)
        folderhrus = os.path.dirname(hrusfile)
        volumehrus = folderhrus+':/root/Gridweights/hru/'
        dimlon = self.dlg.txt_dimlon.text()
        dimlat = self.dlg.txt_dimlat.text()
        varlon = self.dlg.txt_varlon.text()
        varlat = self.dlg.txt_varlat.text()
        subgauge_id = self.dlg.txt_gridid.text()
        #shpattributes = 
        output = self.dlg.file_outputgridweight.filePath()
        outputfolder = folderhrus = os.path.dirname(output)
        outputfile = ntpath.basename(output)

        if self.dlg.rb_subbasinid.isChecked():
            selectedid = ' -s '
        elif self.dlg.rb_gaugeid.isChecked():
            selectedid = ' -b '            
        
        #print(ncextension)
        
        
        pythonConsole = self.iface.mainWindow().findChild(QDockWidget, 'PythonConsole')
        if not pythonConsole or not pythonConsole.isVisible():  #If the python console is closed, open it
            self.iface.actionShowPythonDialog().trigger()
        self.iface.messageBar().pushInfo("Info", "The GridWeights generator process has started. This could take a while.")
        self.iface.mainWindow().repaint()
        self.dockerPull()                   #Calls the function to pull the container
       # self.dockerStart()                  #Calls the function that starts the container
        try:
            print("Attempting to start the container...")
            cmd='docker', 'run', '-t', '-d','-w','/root/BasinMaker','-v', volumenc , '-v', volumehrus, '--name', 'qraven', 'scriptbash/qraven'
            self.dockerCommand(cmd)
            print("The container was started successfully")
        except Exception as e:
            print(e)
        print("Starting the GridWeights generator process, this will take a while to complete")
        if ncextension == '.shp':
            shpattributes = self.dlg.combo_ncattributes.currentText()
            pythoncmd = 'python3 -u ~/Gridweights/derive_grid_weights.py -i ' + '/root/Gridweights/nc/'+ncfilename + ' -f '+ '"'+shpattributes+'"' + ' -r ' + '/root/Gridweights/hru/' + hrusfilename + selectedid + ' ' + subgauge_id + ' -o ' + '/root/Gridweights/'+outputfile #Bash command to start the Gridweights script
            
        else:
            pythoncmd = 'python3 -u ~/Gridweights/derive_grid_weights.py -i ' + '/root/Gridweights/nc/'+ncfilename + ' -d ' + '"'+dimlon+','+dimlat+'"' + ' -v ' + '"'+varlon+','+varlat+'"' +' -r ' + '/root/Gridweights/hru/' + hrusfilename + selectedid + ' ' + subgauge_id + ' -o ' + '/root/Gridweights/'+outputfile #Bash command to start the Gridweights script
        print(pythoncmd)
        cmd ='docker', 'exec','-t', 'qraven','/bin/bash','-i','-c',pythoncmd    #Docker command to run the script
        try:
            os.system("docker start qraven")    #Make sure the container is started. Only needed when the plugin is run a second time
            self.dockerCommand(cmd)
            cmd = 'docker', 'cp', 'qraven:/root/Gridweights/'+outputfile, outputfolder
            self.dockerCommand(cmd)
            print("GridWeights generator has finished processing the files")  
        except Exception as e:
            print("The GridWeights generator process failed...")
            print(e)
        self.iface.messageBar().pushInfo("Info", "The GridWeights generator process has finished. Check the python logs for more details.")
        os.system("docker stop qraven")     #Stops the container after the process
        os.system("docker rm qraven")       #Deletes the container
    #This method opens the rvi file from the input directory and gets two values to populate them in the GUI
    def setModelname(self):
        inputdir = self.dlg.file_runinputdir.filePath() #Get the model input directory
        self.dlg.txt_runnameprefix.clear()
        self.dlg.txt_runrunname.clear()
        try:
            if inputdir:
                for file in os.listdir(inputdir):   #Lists all the files in the input folder
                    if file.endswith(".rvi"):       #Get the RVI file if it exists
                        self.dlg.txt_runnameprefix.setText(file.replace('.rvi','')) #Sets the file name prefix
                        rvifile = inputdir+separator+file
                        with open(rvifile,'r') as rvi:  #Read the RVI file
                            lines = rvi.readlines()
                            for line in lines:
                                if ':RunName' in line:  #loops through the RVI file and searches for the :RunName keyword
                                    params = line.split()
                                    runname = params[params.index(':RunName')+1]    #Get the string after the :RunName keyword
                                    self.dlg.txt_runrunname.setText(runname)    #Set the RunName
        except Exception as e:
            self.iface.messageBar().pushInfo("Info", "Could not populate some information automatically.")
            self.iface.mainWindow().repaint()
            print(e)
    #This method runs a Raven model provided by the user.
    def runRaven(self):
        '''Runs a Raven model just like RavenViewLite3'''
        inputdir = self.dlg.file_runinputdir.filePath() #Get the path where the model files are stored
        outputdir = self.dlg.file_runoutputdir.filePath()   #Get the path where to save the results of the simulation
        ravenExe = self.dlg.file_ravenexe.filePath()    #Get the path to the Raven.exe
        prefix = self.dlg.txt_runnameprefix.text()  #Get the chosen prefix
        runname = self.dlg.txt_runrunname.text()    #Get the runname (this can be empty)
        pathtomodel =inputdir+separator+prefix      #Get the complete path to the model

        pythonConsole = self.iface.mainWindow().findChild(QDockWidget, 'PythonConsole')
        if not pythonConsole or not pythonConsole.isVisible():  #If the python console is closed, open it
            self.iface.actionShowPythonDialog().trigger()       #It allows the user to see the Raven progress
        self.iface.messageBar().pushInfo("Info", "The Raven process has started, this could take a while to complete.")
        self.iface.mainWindow().repaint()

        try:
            cmd = ravenExe, pathtomodel,"-o",outputdir, "-r",runname    #Command that launches the Raven model
            self.dockerCommand(cmd)
        except Exception as e:
            print(e)
            self.iface.messageBar().pushMessage("Error", "An error occured while running Raven. Check the python console for more details.",level=Qgis.Critical)

    #This method opens a new tab in the default web browser and points to the RavenView tool
    def openRavenView(self):
        url = 'http://raven.uwaterloo.ca/RavenView/RavenView.html'
        webbrowser.open(url, new = 2)
    
    #This method plots the resulting hydrograph
    def drawHydrographs(self):
        '''Plots the hydrograph from the ouput of a Raven model'''
        outputdir = self.dlg.file_runoutputdir.filePath()   #Get the path where the results of the simulation are stored
        runname = self.dlg.txt_runrunname.text()    #Get the runname (this can be empty
        if runname:
            filename = outputdir+separator+runname+'_Hydrographs.csv'    #Complete file name
        else: 
            filename = outputdir+separator+'Hydrographs.csv'
        #Pandas could have made this much easier, however the plugin must not depend on other python packages that would
        #require the user to install it manually. Therefore, the csv is read manually.
        try:
            with open(filename, "r") as file:
                csv_reader = csv.reader(file)
                headers = next(csv_reader)
                
                data = {}
                for title in headers:   #Loops through the column names
                    data[title] = []

                for row in csv_reader:
                    for i, title in enumerate(headers): 
                        data[title].append(row[i])   #Adds values inside the columns                   
    
            for i in range(len(data["date"])):
                data["date"][i] = datetime.datetime.strptime(data["date"][i], "%Y-%m-%d")   #Converts the date from string to datetime

            for i in range(len(data[headers[3]])):  #Using indexes here since the column name changes from models to models
                #Converts the precipitations from string to float. If it encounters a value it cannot convert such as "---" which
                #Raven sometimes adds, the value is set to 0
                try:
                    data[headers[3]][i] = float(data[headers[3]][i])
                except:
                    data[headers[3]][i] = 0
                    print("Warning : A value could not be converted from string to float. Overwritting with 0.")
            for i in range(len(data[headers[4]])):
                #Converts the flow from string to float
                try:
                    data[headers[4]][i] = float(data[headers[4]][i])
                except:
                    data[headers[4]][i] = 0
                    print("Warning : A value could not be converted from string to float. Overwritting with 0.")
            for i in range(len(data[headers[5]])):
                #Converts the observed flow from string to float
                try:
                    data[headers[5]][i] = float(data[headers[5]][i])
                except:
                    data[headers[5]][i] = 0
                    print("Warning : A value could not be converted from string to float. Overwritting with 0.")

            fig, ax = plt.subplots()
            ax.plot(data["date"], data[headers[3]], label=headers[3]) #Plots the precipitations by dates
            ax.plot(data["date"], data[headers[4]],label=headers[4])  #Plots the flow by dates
            ax.plot(data["date"], data[headers[5]],label=headers[5])    #Plots the observed flow by date
            ax.legend(loc="upper left") #Adds a legend
            ax.set_title("Hydrograph")  #Sets the title of the graph          
            fig.autofmt_xdate()
            fig.show()
        except Exception as e:
            print(e)
            self.iface.messageBar().pushMessage("Error", "An error occured while attempting to draw the hydrograph. Check the python console for more details.",level=Qgis.Critical)
    
    def checkUpdate(self):
        try:
            metadatafile = Path(__file__).parent / "metadata.txt"
            with open(metadatafile,'r') as metadata:  #Read the metadata file
                lines = metadata.readlines()
                for line in lines:
                    if 'version=' in line:  #loops through the metadata file and searches for the plugin version
                        pluginversion = line.split()
                        print(pluginversion[0])
            print("Looking for updates")
            link = "https://raw.githubusercontent.com/Scriptbash/QRaven/main/qraven/metadata.txt"
            page = requests.get(link)
            content = page.text     
            keywords = content.split()
            if pluginversion[0] in keywords:
                print("version is up to date")
            else:
                print("Found an update. Please install the latest version of the plugin here: https://github.com/Scriptbash/QRaven/releases")
                self.dlg.lbl_update.setText('An update is available, please install the latest version <a href="https://github.com/Scriptbash/QRaven/releases">https://github.com/Scriptbash/QRaven/releases</a>')
                #self.iface.messageBar().pushInfo("Info", "A QRaven update is available, please install the latest version https://github.com/Scriptbash/QRaven/releases")
        except Exception as e:
            print(e)
            print("Could not check for an update. Verify your internet connection.")

#This function returns the user's operating system. Mainly used to put slashes and backslashes accordingly in paths            
def checkOS():
    '''Makes a simple check to verify which operating system the user is using.

        Returns a slash or backslash as a string depending on the OS.
    '''
    if platform == "linux" or platform == "linux2":
        return "linux","/"
    elif platform == "darwin":
        return "macos", "/"
    elif platform == "win32":
        os.environ["PATH"] = "C:\\Program Files\\Docker\\Docker\\resources\\bin"    #This is needed so that the docker commands work on Windows
        return "windows", "\\"

computerOS, separator = checkOS()

#Lists with all of the Raven algorithms
precipalg =['PRECIP_RAVEN']
canopevapAlg = ['CANEVP_RUTTER','CANEVP_MAXIMUM']
soilevapAlg = ['SOILEVAP_VIC','SOILEVAP_HBV','SOILEVAP_CHU','SOILEVAP_TOPMODEL','SOILEVAP_SEQUEN','SOILEVAP_ROOTFRAC','SOILEVAP_GAWSER']
lakeevapAlg = ['LAKE_EVAP_BASIC']
openwaterevapAlg = ['OPEN_WATER_EVAP']
infiltrationAlg = ['INF_RATIONAL','INF_SCS','INF_ALL_INFILTRATES','INF_GREEN_AMPT','INF_GA_SIMPLE',
                    'INF_UPSCALED_GREEN_AMPT','INF_HBV','INF_UBC','INF_VIC','INF_VIC_ARNO','INF_PRMS'
                    ]
percolationAlg = ['PERC_GAWSER','PERC_LINEAR','PERC_POWER_LAW','PERC_PRMS','PERC_SACRAMENTO','PERC_CONSTANT','PERC_GR4J']
cappilaryriseAlg = ['CRISE_HBV']
baseflowAlg = ['BASE_LINEAR','BASE_POWERLAW','BASE_CONSTANT','BASE_VIC','BASE_THRESH_POWER','BASE_GR4J','BASE_TOPMODEL']
interflowAlg = ['PRMS']
seepageAlg = ['SEEP_LINEAR']
depresoverflowAlg = ['DFLOW_THRESHPOW','DFLOW_LINEAR']
lakereleaseAlg = ['LAKEREL_LINEAR']
abstractionAlg = ['ABST_PERCENTAGE','ABST_FILL','ABST_SCS']
snowmeltAlg = ['MELT_POTMELT']
snowrefreezeAlg = ['FREEZE_DEGREE_DAY']
snowbalanceAlg = ['SNOBAL_SIMPLE_MELT','SNOBAL_COLD_CONTENT','SNOBAL_HBV','SNOBAL_TWO_LAYER','SNOBAL_CEMA_NEIGE',
                    'SNOBAL_GAWSER','SNOBAL_UBC'
                    ]
sublimationAlg = ['SUBLIM_SVERDRUP','SUBLIM_KUZMIN','SUBLIM_CENTRAL_SIERRA','SUBLIM_PSBM','SUBLIM_WILLIAMS']
snowalbedoevolveAlg = ['SNOALB_UBC']
canopydripAlg = ['CANDRIP_RUTTER','CANDRIP_SLOWDRAIN']
cropheatunitevAlg = ['CHU_ONTARIO']
glaciermeltAlg = ['GMELT_SIMPLET_MELT','GMELT_HBV','GMELT_UBC']
glacierreleaseAlg = ['GRELEASE_LINEAR','GRELEASE_HBV_EC']
flushAlg = ['FLUSH_RAVEN']
overflowAlg = ['OVERFLOW_RAVEN']
splitAlg = ['RAVEN_DEFAULT']
convolutionAlg = ['CONVOL_GR4J1','CONVOL_GR4J2']
lateralflushAlg = ['RAVEN_DEFAULT']