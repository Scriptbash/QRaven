# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QRaven

 A QGIS plugin to help generate input files for Raven
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-03-22
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Francis Lapointe
        email                : francis.lapointe5@usherbrooke.ca
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import *
#from PyQt5 import QFileDialog
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .qraven_dialog import QRavenDialog

import os.path
from sys import platform
import subprocess
from subprocess import Popen, PIPE

class QRaven:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'QRaven_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&QRaven')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('QRaven', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/qraven/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Generate Raven input files'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&QRaven'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = QRavenDialog()


        #If the checkbox is checked/unchecked, enables/disables the EndDate/Duration field
        self.dlg.chk_duration.stateChanged.connect(self.toggleDuration)
        #Calls the function to enable/disable the spinbox for the soilmodel
        self.dlg.combo_soilmod.activated.connect(self.toggleSoilModel)
        #Calls the function to browse the computer for an output folder
        self.dlg.btn_outputdir.clicked.connect(self.browseDirectory)
     
        # #Calls the function to add a custom output field
        # self.dlg.btn_addoutput.clicked.connect(self.addOutput)

        #Calls the function to write the RVI file
        self.dlg.btn_write.clicked.connect(self.writeRVI)

        #Calls the function to start the docker container
        self.dlg.btn_dockerrun.clicked.connect(self.dockerinit)
        #Calls the function to remove the docker container
        self.dlg.btn_dockerrm.clicked.connect(self.dockerdelete)

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()

        # See if OK was pressed
        if result:
            # May remove completely this and keep only a close button in the GUI
            pass
    
    #This function enables and disables the EndDate and Duration widget based on the checkbox
    def toggleDuration(self):
        if self.dlg.chk_duration.isChecked():
            self.dlg.date_enddate.setEnabled(False)
            self.dlg.spin_duration.setEnabled(True)
        else:
            self.dlg.date_enddate.setEnabled(True)
            self.dlg.spin_duration.setEnabled(False) 

    #This function enables and disables the spinbox next to the SoilModel combobox depending on the selected value of the combobox
    def toggleSoilModel(self):
        if self.dlg.combo_soilmod.currentText().lower() == "soil_multilayer":
            self.dlg.spin_soilmod.setEnabled(True)
        else:
            self.dlg.spin_soilmod.setEnabled(False)

    #This function opens a file explorer to select an output folder
    def browseDirectory(self):
        dir = str(QFileDialog.getExistingDirectory(None, "Select Directory"))
        self.dlg.txt_outputdir.setText(dir)
        
    # #This function adds another row of custom output if the "+" button is clicked
    # def addOutput(self):
    #     self.time_comboBox = QComboBox()
    #     self.stat_comboBox = QComboBox()
    #     self.grid = QGridLayout()
    #     self.grid.addWidget(self.time_comboBox,3,0)
        
    #     self.dlg.setLayout(self.grid)

    #     print("Added a custom output")


    #This function writes all the parameters entered by the user into the RVI file
    def writeRVI(self):
        paramDict = self.getParams()
        print(paramDict)
        outputdir = self.dlg.txt_outputdir.text()
        modelName = self.dlg.txt_modname.text()
        print(outputdir)
        try:
            if computerOS == "linux" or computerOS == "macos":
                pathToFolder = outputdir+'/'+modelName
            else:
                pathToFolder = outputdir+'\\'+modelName
            with open(pathToFolder+".rvi","w") as rvi:
                 for key, value in paramDict.items():
                     if value != '': 
                        rvi.write('%s:%s\n' % (key, value))
                #rvi.write("This is some dummy text")
            print("RVI file written successfully")
        except Exception as e:
            print("Unable to write the RVI file")
            print(e)

    #This function gathers all the parameters entered by the user and return them into a dictionary
    def getParams(self):
        #Get the start date
        startDateTmp = self.dlg.date_startdate.dateTime()
        startDate = str(startDateTmp.toPyDateTime())
        #Get the end date or duration
        if self.dlg.chk_duration.isChecked():
            keyDuration = "Duration" 
            duration = str(self.dlg.spin_duration.value())
        else:
            keyDuration = "EndDate"
            endDateTmp = self.dlg.date_enddate.dateTime()
            duration = str(endDateTmp.toPyDateTime())
            #Must not forget to add condition in the dictionary
        #Get the time step
        timeStepTmp = self.dlg.date_timestep.time()
        timeStep = str(timeStepTmp.toPyTime())
        #Get soil model
        if self.dlg.combo_soilmod.currentText().lower() == "soil_multilayer":
            soilMod = self.dlg.combo_soilmod.currentText() + ' ' + str(self.dlg.spin_soilmod.value())
        else:
            soilMod = self.dlg.combo_soilmod.currentText()
        #Get Define HRU groups
        defHRUGroups = self.dlg.txt_defhru.toPlainText()
        #Get catchment route
        catchment = self.dlg.combo_catchment.currentText()
        #Get routing
        routing = self.dlg.combo_routing.currentText()
        #Get method
        method= self.dlg.combo_method.currentText()   
        #Get interpolation method
        interpolation = self.dlg.combo_interpo.currentText() #Must add the file option
        #Get evaporation
        evaporation = self.dlg.combo_evapo.currentText()     
        #Get rain snow fraction
        rainsnowfract = self.dlg.combo_rainsnowfrac.currentText()
        #Get OW_Evaporation
        owevapo = self.dlg.combo_owevapo.currentText()
        #Get OroPrecipCorrect
        oroprecip = self.dlg.combo_oroprecip.currentText()
        #Get OroTempCorrect
        orotemp = self.dlg.combo_orotemp.currentText()
        #Get OroPetCorrect
        oropet = self.dlg.combo_oropet.currentText()
        #Get CloudCoverMethod
        cloudcover = self.dlg.combo_cloudcover.currentText()
        #Get AirPressureMethod
        airpressure = self.dlg.combo_airpressure.currentText()
        #Get PotentionMelt
        potmelt = self.dlg.combo_potentialmelt.currentText()
        #Get MonthlyInterpolationMethod
        monthlyinterpo = self.dlg.combo_monthlyinterpo.currentText()
        #Get LakeStorage
        lakestorage = self.dlg.combo_lakestorage.currentText()
        #Get SWRadiationMethod
        swradiation = self.dlg.combo_swradation.currentText()
        #Get SWCanopyCorrect
        swcanopy = self.dlg.combo_swcanopy.currentText()
        #Get SWCloudCorrect
        swcloud = self.dlg.combo_swcloud.currentText()
        #Get LWRadiationMethod
        lwradiation = self.dlg.combo_lwradation.currentText()
        #Get WindSpeedMethod
        windspeed = self.dlg.combo_windspeed.currentText()
        #Get RelativeHumidityMethod
        relhumidity = self.dlg.combo_relhumidity.currentText()
        #Get PrecipIceptFract
        precipicept = self.dlg.combo_precipicept.currentText()
        #Get RechargeMethod
        recharge = self.dlg.combo_recharge.currentText()
        #Get SubdailyMethod
        subdaily = self.dlg.combo_subdaily.currentText()
        #Get Calendar
        calendar = self.dlg.combo_calendar.currentText()


        #Create the dictionary
        paramsDict = { 
            "Calendar"                   : calendar,
            "StartDate"                  : startDate,
            keyDuration                  : duration,
            "TimeStep"                   : timeStep,
            "SoilModel"                  : soilMod,
            "DefineHRUGroups"            : defHRUGroups,
            "CatchmentRoute"             : catchment,
            "Routing"                    : routing,
            "Method"                     : method,
            "InterpolationMethod"        : interpolation,
            "Evaporation"                : evaporation,
            "RainSnowFraction"           : rainsnowfract,
            "OW_Evaporation"             : owevapo,
            "OroPrecipCorrect"           : oroprecip,
            "OroTempCorrect"             : orotemp,
            "OroPetCorrect"              : oropet,
            "CloudCoverMethod"           : cloudcover,
            "AirPressureMethod"          : airpressure,
            "PotentialMelt"              : potmelt,
            "MonthlyInterpolationMethod" : monthlyinterpo,
            "LakeStorage"                : lakestorage,
            "SWRadiationMEthod"          : swradiation,
            "SWCanopyCorrect"            : swcanopy,
            "SWCloudCorrect"             : swcloud,
            "LWRadationMethod"           : lwradiation,
            "WindSpeedMethod"            : windspeed,
            "RelativeHumidityMethod"     : relhumidity,
            "PrecipIceptFract"           : precipicept,
            "RechargeMethod"             : recharge,
            "SubdailyMethod"             : subdaily
            
        }

        

        return paramsDict
    #This function sets up the scriptbash/basinmaker docker container. Pulls, starts and sets the python path
    def dockerinit(self):
        pythonpaths = [
                        "export PYTHONPATH=$PYTHONPATH:'/usr/lib/grass78/etc/python'",
                        "export PYTHONPATH=$PYTHONPATH:'/usr/share/qgis/python/plugins'",
                        "export PYTHONPATH=$PYTHONPATH:'/usr/share/qgis/python'",
                        "Xvfb :99 -screen 0 640x480x8 -nolisten tcp &"
                    ] 
        try:
            print("pulling")
            cmd='docker', 'pull', 'scriptbash/basinmaker'
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE)
            while True:
                output = process.stdout.readline()
                if output == b'': #and process.poll() is not None:
                    break
                if output:
                    #test = str(output.strip())
                    #self.dlg.txt_console.appendPlainText(test)
                    print(output.strip())
            rc = process.poll()
            print("went out of the loop")
        except Exception as e:
            print(e)

        #!!!Missing the docker run command, export python paths, xvfb to fake a display!!!
      
        
    #This function fully removes the container, as well as the image to free up space
    def dockerdelete(self):
        try:
            self.dlg.txt_console.appendPlainText("Making sure the container is stopped > docker stop bmaker")
            os.system("docker stop bmaker")
            self.dlg.txt_console.appendPlainText("Successfully stopped the containter")
            self.dlg.txt_console.appendPlainText("Removing the docker container > docker rm bmaker")
            os.system("docker rm bmaker")
            self.dlg.txt_console.appendPlainText("Successfully removed the container > docker rmi scriptbash/basinmaker")
            self.dlg.txt_console.appendPlainText("Removing the image")
            os.system("docker rmi scriptbash/basinmaker")
            self.dlg.txt_console.appendPlainText("Successfully removed the image. Everything was removed.")
        except Exception as e:
            self.dlg.txt_console.appendPlainText("An error occured while attempting to remove the container and image. Please remove them manually.")
            print("An error occured while attempting to remove the docker container and image")
            print(e)


#This function return the user's operating system. Mainly used to put slashes and backslashes accordingly in paths            
def checkOS():
    if platform == "linux" or platform == "linux2":
        return "linux"
    elif platform == "darwin":
        return "macos"
    elif platform == "win32":
        return "windows"
computerOS = checkOS()
